// Code generated by protoc-gen-gogo.
// source: epaxosprotobuf/epaxos.proto
// DO NOT EDIT!

/*
	Package epaxosprotobuf is a generated protocol buffer package.

	It is generated from these files:
		epaxosprotobuf/epaxos.proto

	It has these top-level messages:
		PreAccept
		PreAcceptReply
		PreAcceptOK
		Accept
		AcceptReply
		Commit
		CommitShort
		Command
		Empty
*/
package epaxosprotobuf

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import strconv "strconv"

import (
	"encoding/binary"
	"hash/fnv"
	"log"
	"net"
	"sort"
	"sync"
	"time"

	"google.golang.org/grpc/codes"
)

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type OK int32

const (
	NONE           OK = 0
	PREACCEPTED    OK = 1
	PREACCEPTED_EQ OK = 2
	ACCEPTED       OK = 3
	COMMITTED      OK = 4
	EXECUTED       OK = 5
)

var OK_name = map[int32]string{
	0: "NONE",
	1: "PREACCEPTED",
	2: "PREACCEPTED_EQ",
	3: "ACCEPTED",
	4: "COMMITTED",
	5: "EXECUTED",
}
var OK_value = map[string]int32{
	"NONE":           0,
	"PREACCEPTED":    1,
	"PREACCEPTED_EQ": 2,
	"ACCEPTED":       3,
	"COMMITTED":      4,
	"EXECUTED":       5,
}

func (OK) EnumDescriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{0} }

type Command_Operation int32

const (
	NONEX  Command_Operation = 0
	PUT    Command_Operation = 1
	GET    Command_Operation = 2
	DELETE Command_Operation = 3
	RLOCK  Command_Operation = 4
	WLOCK  Command_Operation = 5
)

var Command_Operation_name = map[int32]string{
	0: "NONEX",
	1: "PUT",
	2: "GET",
	3: "DELETE",
	4: "RLOCK",
	5: "WLOCK",
}
var Command_Operation_value = map[string]int32{
	"NONEX":  0,
	"PUT":    1,
	"GET":    2,
	"DELETE": 3,
	"RLOCK":  4,
	"WLOCK":  5,
}

func (Command_Operation) EnumDescriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{7, 0} }

type PreAccept struct {
	LeaderId int32      `protobuf:"varint,1,opt,name=leader_id,json=leaderId,proto3" json:"leader_id,omitempty"`
	Replica  int32      `protobuf:"varint,2,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance int32      `protobuf:"varint,3,opt,name=instance,proto3" json:"instance,omitempty"`
	Ballot   int32      `protobuf:"varint,4,opt,name=ballot,proto3" json:"ballot,omitempty"`
	Seq      int32      `protobuf:"varint,5,opt,name=seq,proto3" json:"seq,omitempty"`
	Deps     []int32    `protobuf:"varint,6,rep,name=deps" json:"deps,omitempty"`
	Command  []*Command `protobuf:"bytes,7,rep,name=command" json:"command,omitempty"`
}

func (m *PreAccept) Reset()                    { *m = PreAccept{} }
func (*PreAccept) ProtoMessage()               {}
func (*PreAccept) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{0} }

func (m *PreAccept) GetCommand() []*Command {
	if m != nil {
		return m.Command
	}
	return nil
}

type PreAcceptReply struct {
	Replica       int32   `protobuf:"varint,1,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance      int32   `protobuf:"varint,2,opt,name=instance,proto3" json:"instance,omitempty"`
	Ok            OK      `protobuf:"varint,3,opt,name=ok,proto3,enum=epaxosprotobuf.OK" json:"ok,omitempty"`
	Ballot        int32   `protobuf:"varint,4,opt,name=ballot,proto3" json:"ballot,omitempty"`
	Seq           int32   `protobuf:"varint,5,opt,name=seq,proto3" json:"seq,omitempty"`
	Deps          []int32 `protobuf:"varint,6,rep,name=deps" json:"deps,omitempty"`
	CommittedDeps []int32 `protobuf:"varint,7,rep,name=committed_deps,json=committedDeps" json:"committed_deps,omitempty"`
}

func (m *PreAcceptReply) Reset()                    { *m = PreAcceptReply{} }
func (*PreAcceptReply) ProtoMessage()               {}
func (*PreAcceptReply) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{1} }

type PreAcceptOK struct {
	Instance int32 `protobuf:"varint,1,opt,name=Instance,json=instance,proto3" json:"Instance,omitempty"`
}

func (m *PreAcceptOK) Reset()                    { *m = PreAcceptOK{} }
func (*PreAcceptOK) ProtoMessage()               {}
func (*PreAcceptOK) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{2} }

type Accept struct {
	LeaderId int32   `protobuf:"varint,1,opt,name=leader_id,json=leaderId,proto3" json:"leader_id,omitempty"`
	Replica  int32   `protobuf:"varint,2,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance int32   `protobuf:"varint,3,opt,name=instance,proto3" json:"instance,omitempty"`
	Ballot   int32   `protobuf:"varint,4,opt,name=ballot,proto3" json:"ballot,omitempty"`
	Count    int32   `protobuf:"varint,5,opt,name=count,proto3" json:"count,omitempty"`
	Seq      int32   `protobuf:"varint,6,opt,name=seq,proto3" json:"seq,omitempty"`
	Deps     []int32 `protobuf:"varint,7,rep,name=deps" json:"deps,omitempty"`
}

func (m *Accept) Reset()                    { *m = Accept{} }
func (*Accept) ProtoMessage()               {}
func (*Accept) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{3} }

type AcceptReply struct {
	Replica  int32 `protobuf:"varint,1,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance int32 `protobuf:"varint,2,opt,name=instance,proto3" json:"instance,omitempty"`
	Ok       OK    `protobuf:"varint,3,opt,name=ok,proto3,enum=epaxosprotobuf.OK" json:"ok,omitempty"`
	Ballot   int32 `protobuf:"varint,4,opt,name=ballot,proto3" json:"ballot,omitempty"`
}

func (m *AcceptReply) Reset()                    { *m = AcceptReply{} }
func (*AcceptReply) ProtoMessage()               {}
func (*AcceptReply) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{4} }

type Commit struct {
	LeaderId int32      `protobuf:"varint,1,opt,name=leader_id,json=leaderId,proto3" json:"leader_id,omitempty"`
	Replica  int32      `protobuf:"varint,2,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance int32      `protobuf:"varint,3,opt,name=instance,proto3" json:"instance,omitempty"`
	Command  []*Command `protobuf:"bytes,4,rep,name=command" json:"command,omitempty"`
	Seq      int32      `protobuf:"varint,5,opt,name=seq,proto3" json:"seq,omitempty"`
	Deps     []int32    `protobuf:"varint,6,rep,name=deps" json:"deps,omitempty"`
}

func (m *Commit) Reset()                    { *m = Commit{} }
func (*Commit) ProtoMessage()               {}
func (*Commit) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{5} }

func (m *Commit) GetCommand() []*Command {
	if m != nil {
		return m.Command
	}
	return nil
}

type CommitShort struct {
	LeaderId int32   `protobuf:"varint,1,opt,name=leader_id,json=leaderId,proto3" json:"leader_id,omitempty"`
	Replica  int32   `protobuf:"varint,2,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance int32   `protobuf:"varint,3,opt,name=instance,proto3" json:"instance,omitempty"`
	Count    int32   `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	Seq      int32   `protobuf:"varint,5,opt,name=seq,proto3" json:"seq,omitempty"`
	Deps     []int32 `protobuf:"varint,6,rep,name=deps" json:"deps,omitempty"`
}

func (m *CommitShort) Reset()                    { *m = CommitShort{} }
func (*CommitShort) ProtoMessage()               {}
func (*CommitShort) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{6} }

type Command struct {
	Op Command_Operation `protobuf:"varint,1,opt,name=op,proto3,enum=epaxosprotobuf.Command_Operation" json:"op,omitempty"`
	K  int64             `protobuf:"varint,2,opt,name=k,proto3" json:"k,omitempty"`
	V  int64             `protobuf:"varint,3,opt,name=v,proto3" json:"v,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{7} }

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{8} }

func init() {
	proto.RegisterType((*PreAccept)(nil), "epaxosprotobuf.PreAccept")
	proto.RegisterType((*PreAcceptReply)(nil), "epaxosprotobuf.PreAcceptReply")
	proto.RegisterType((*PreAcceptOK)(nil), "epaxosprotobuf.PreAcceptOK")
	proto.RegisterType((*Accept)(nil), "epaxosprotobuf.Accept")
	proto.RegisterType((*AcceptReply)(nil), "epaxosprotobuf.AcceptReply")
	proto.RegisterType((*Commit)(nil), "epaxosprotobuf.Commit")
	proto.RegisterType((*CommitShort)(nil), "epaxosprotobuf.CommitShort")
	proto.RegisterType((*Command)(nil), "epaxosprotobuf.Command")
	proto.RegisterType((*Empty)(nil), "epaxosprotobuf.Empty")
	proto.RegisterEnum("epaxosprotobuf.OK", OK_name, OK_value)
	proto.RegisterEnum("epaxosprotobuf.Command_Operation", Command_Operation_name, Command_Operation_value)
}
func (x OK) String() string {
	s, ok := OK_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Command_Operation) String() string {
	s, ok := Command_Operation_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *PreAccept) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PreAccept)
	if !ok {
		that2, ok := that.(PreAccept)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *PreAccept")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PreAccept but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PreAccept but is not nil && this == nil")
	}
	if this.LeaderId != that1.LeaderId {
		return fmt.Errorf("LeaderId this(%v) Not Equal that(%v)", this.LeaderId, that1.LeaderId)
	}
	if this.Replica != that1.Replica {
		return fmt.Errorf("Replica this(%v) Not Equal that(%v)", this.Replica, that1.Replica)
	}
	if this.Instance != that1.Instance {
		return fmt.Errorf("Instance this(%v) Not Equal that(%v)", this.Instance, that1.Instance)
	}
	if this.Ballot != that1.Ballot {
		return fmt.Errorf("Ballot this(%v) Not Equal that(%v)", this.Ballot, that1.Ballot)
	}
	if this.Seq != that1.Seq {
		return fmt.Errorf("Seq this(%v) Not Equal that(%v)", this.Seq, that1.Seq)
	}
	if len(this.Deps) != len(that1.Deps) {
		return fmt.Errorf("Deps this(%v) Not Equal that(%v)", len(this.Deps), len(that1.Deps))
	}
	for i := range this.Deps {
		if this.Deps[i] != that1.Deps[i] {
			return fmt.Errorf("Deps this[%v](%v) Not Equal that[%v](%v)", i, this.Deps[i], i, that1.Deps[i])
		}
	}
	if len(this.Command) != len(that1.Command) {
		return fmt.Errorf("Command this(%v) Not Equal that(%v)", len(this.Command), len(that1.Command))
	}
	for i := range this.Command {
		if !this.Command[i].Equal(that1.Command[i]) {
			return fmt.Errorf("Command this[%v](%v) Not Equal that[%v](%v)", i, this.Command[i], i, that1.Command[i])
		}
	}
	return nil
}
func (this *PreAccept) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PreAccept)
	if !ok {
		that2, ok := that.(PreAccept)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.LeaderId != that1.LeaderId {
		return false
	}
	if this.Replica != that1.Replica {
		return false
	}
	if this.Instance != that1.Instance {
		return false
	}
	if this.Ballot != that1.Ballot {
		return false
	}
	if this.Seq != that1.Seq {
		return false
	}
	if len(this.Deps) != len(that1.Deps) {
		return false
	}
	for i := range this.Deps {
		if this.Deps[i] != that1.Deps[i] {
			return false
		}
	}
	if len(this.Command) != len(that1.Command) {
		return false
	}
	for i := range this.Command {
		if !this.Command[i].Equal(that1.Command[i]) {
			return false
		}
	}
	return true
}
func (this *PreAcceptReply) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PreAcceptReply)
	if !ok {
		that2, ok := that.(PreAcceptReply)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *PreAcceptReply")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PreAcceptReply but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PreAcceptReply but is not nil && this == nil")
	}
	if this.Replica != that1.Replica {
		return fmt.Errorf("Replica this(%v) Not Equal that(%v)", this.Replica, that1.Replica)
	}
	if this.Instance != that1.Instance {
		return fmt.Errorf("Instance this(%v) Not Equal that(%v)", this.Instance, that1.Instance)
	}
	if this.Ok != that1.Ok {
		return fmt.Errorf("Ok this(%v) Not Equal that(%v)", this.Ok, that1.Ok)
	}
	if this.Ballot != that1.Ballot {
		return fmt.Errorf("Ballot this(%v) Not Equal that(%v)", this.Ballot, that1.Ballot)
	}
	if this.Seq != that1.Seq {
		return fmt.Errorf("Seq this(%v) Not Equal that(%v)", this.Seq, that1.Seq)
	}
	if len(this.Deps) != len(that1.Deps) {
		return fmt.Errorf("Deps this(%v) Not Equal that(%v)", len(this.Deps), len(that1.Deps))
	}
	for i := range this.Deps {
		if this.Deps[i] != that1.Deps[i] {
			return fmt.Errorf("Deps this[%v](%v) Not Equal that[%v](%v)", i, this.Deps[i], i, that1.Deps[i])
		}
	}
	if len(this.CommittedDeps) != len(that1.CommittedDeps) {
		return fmt.Errorf("CommittedDeps this(%v) Not Equal that(%v)", len(this.CommittedDeps), len(that1.CommittedDeps))
	}
	for i := range this.CommittedDeps {
		if this.CommittedDeps[i] != that1.CommittedDeps[i] {
			return fmt.Errorf("CommittedDeps this[%v](%v) Not Equal that[%v](%v)", i, this.CommittedDeps[i], i, that1.CommittedDeps[i])
		}
	}
	return nil
}
func (this *PreAcceptReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PreAcceptReply)
	if !ok {
		that2, ok := that.(PreAcceptReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Replica != that1.Replica {
		return false
	}
	if this.Instance != that1.Instance {
		return false
	}
	if this.Ok != that1.Ok {
		return false
	}
	if this.Ballot != that1.Ballot {
		return false
	}
	if this.Seq != that1.Seq {
		return false
	}
	if len(this.Deps) != len(that1.Deps) {
		return false
	}
	for i := range this.Deps {
		if this.Deps[i] != that1.Deps[i] {
			return false
		}
	}
	if len(this.CommittedDeps) != len(that1.CommittedDeps) {
		return false
	}
	for i := range this.CommittedDeps {
		if this.CommittedDeps[i] != that1.CommittedDeps[i] {
			return false
		}
	}
	return true
}
func (this *PreAcceptOK) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PreAcceptOK)
	if !ok {
		that2, ok := that.(PreAcceptOK)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *PreAcceptOK")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PreAcceptOK but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PreAcceptOK but is not nil && this == nil")
	}
	if this.Instance != that1.Instance {
		return fmt.Errorf("Instance this(%v) Not Equal that(%v)", this.Instance, that1.Instance)
	}
	return nil
}
func (this *PreAcceptOK) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PreAcceptOK)
	if !ok {
		that2, ok := that.(PreAcceptOK)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Instance != that1.Instance {
		return false
	}
	return true
}
func (this *Accept) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Accept)
	if !ok {
		that2, ok := that.(Accept)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Accept")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Accept but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Accept but is not nil && this == nil")
	}
	if this.LeaderId != that1.LeaderId {
		return fmt.Errorf("LeaderId this(%v) Not Equal that(%v)", this.LeaderId, that1.LeaderId)
	}
	if this.Replica != that1.Replica {
		return fmt.Errorf("Replica this(%v) Not Equal that(%v)", this.Replica, that1.Replica)
	}
	if this.Instance != that1.Instance {
		return fmt.Errorf("Instance this(%v) Not Equal that(%v)", this.Instance, that1.Instance)
	}
	if this.Ballot != that1.Ballot {
		return fmt.Errorf("Ballot this(%v) Not Equal that(%v)", this.Ballot, that1.Ballot)
	}
	if this.Count != that1.Count {
		return fmt.Errorf("Count this(%v) Not Equal that(%v)", this.Count, that1.Count)
	}
	if this.Seq != that1.Seq {
		return fmt.Errorf("Seq this(%v) Not Equal that(%v)", this.Seq, that1.Seq)
	}
	if len(this.Deps) != len(that1.Deps) {
		return fmt.Errorf("Deps this(%v) Not Equal that(%v)", len(this.Deps), len(that1.Deps))
	}
	for i := range this.Deps {
		if this.Deps[i] != that1.Deps[i] {
			return fmt.Errorf("Deps this[%v](%v) Not Equal that[%v](%v)", i, this.Deps[i], i, that1.Deps[i])
		}
	}
	return nil
}
func (this *Accept) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Accept)
	if !ok {
		that2, ok := that.(Accept)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.LeaderId != that1.LeaderId {
		return false
	}
	if this.Replica != that1.Replica {
		return false
	}
	if this.Instance != that1.Instance {
		return false
	}
	if this.Ballot != that1.Ballot {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	if this.Seq != that1.Seq {
		return false
	}
	if len(this.Deps) != len(that1.Deps) {
		return false
	}
	for i := range this.Deps {
		if this.Deps[i] != that1.Deps[i] {
			return false
		}
	}
	return true
}
func (this *AcceptReply) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AcceptReply)
	if !ok {
		that2, ok := that.(AcceptReply)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AcceptReply")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AcceptReply but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AcceptReply but is not nil && this == nil")
	}
	if this.Replica != that1.Replica {
		return fmt.Errorf("Replica this(%v) Not Equal that(%v)", this.Replica, that1.Replica)
	}
	if this.Instance != that1.Instance {
		return fmt.Errorf("Instance this(%v) Not Equal that(%v)", this.Instance, that1.Instance)
	}
	if this.Ok != that1.Ok {
		return fmt.Errorf("Ok this(%v) Not Equal that(%v)", this.Ok, that1.Ok)
	}
	if this.Ballot != that1.Ballot {
		return fmt.Errorf("Ballot this(%v) Not Equal that(%v)", this.Ballot, that1.Ballot)
	}
	return nil
}
func (this *AcceptReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AcceptReply)
	if !ok {
		that2, ok := that.(AcceptReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Replica != that1.Replica {
		return false
	}
	if this.Instance != that1.Instance {
		return false
	}
	if this.Ok != that1.Ok {
		return false
	}
	if this.Ballot != that1.Ballot {
		return false
	}
	return true
}
func (this *Commit) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Commit)
	if !ok {
		that2, ok := that.(Commit)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Commit")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Commit but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Commit but is not nil && this == nil")
	}
	if this.LeaderId != that1.LeaderId {
		return fmt.Errorf("LeaderId this(%v) Not Equal that(%v)", this.LeaderId, that1.LeaderId)
	}
	if this.Replica != that1.Replica {
		return fmt.Errorf("Replica this(%v) Not Equal that(%v)", this.Replica, that1.Replica)
	}
	if this.Instance != that1.Instance {
		return fmt.Errorf("Instance this(%v) Not Equal that(%v)", this.Instance, that1.Instance)
	}
	if len(this.Command) != len(that1.Command) {
		return fmt.Errorf("Command this(%v) Not Equal that(%v)", len(this.Command), len(that1.Command))
	}
	for i := range this.Command {
		if !this.Command[i].Equal(that1.Command[i]) {
			return fmt.Errorf("Command this[%v](%v) Not Equal that[%v](%v)", i, this.Command[i], i, that1.Command[i])
		}
	}
	if this.Seq != that1.Seq {
		return fmt.Errorf("Seq this(%v) Not Equal that(%v)", this.Seq, that1.Seq)
	}
	if len(this.Deps) != len(that1.Deps) {
		return fmt.Errorf("Deps this(%v) Not Equal that(%v)", len(this.Deps), len(that1.Deps))
	}
	for i := range this.Deps {
		if this.Deps[i] != that1.Deps[i] {
			return fmt.Errorf("Deps this[%v](%v) Not Equal that[%v](%v)", i, this.Deps[i], i, that1.Deps[i])
		}
	}
	return nil
}
func (this *Commit) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Commit)
	if !ok {
		that2, ok := that.(Commit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.LeaderId != that1.LeaderId {
		return false
	}
	if this.Replica != that1.Replica {
		return false
	}
	if this.Instance != that1.Instance {
		return false
	}
	if len(this.Command) != len(that1.Command) {
		return false
	}
	for i := range this.Command {
		if !this.Command[i].Equal(that1.Command[i]) {
			return false
		}
	}
	if this.Seq != that1.Seq {
		return false
	}
	if len(this.Deps) != len(that1.Deps) {
		return false
	}
	for i := range this.Deps {
		if this.Deps[i] != that1.Deps[i] {
			return false
		}
	}
	return true
}
func (this *CommitShort) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CommitShort)
	if !ok {
		that2, ok := that.(CommitShort)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CommitShort")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CommitShort but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CommitShort but is not nil && this == nil")
	}
	if this.LeaderId != that1.LeaderId {
		return fmt.Errorf("LeaderId this(%v) Not Equal that(%v)", this.LeaderId, that1.LeaderId)
	}
	if this.Replica != that1.Replica {
		return fmt.Errorf("Replica this(%v) Not Equal that(%v)", this.Replica, that1.Replica)
	}
	if this.Instance != that1.Instance {
		return fmt.Errorf("Instance this(%v) Not Equal that(%v)", this.Instance, that1.Instance)
	}
	if this.Count != that1.Count {
		return fmt.Errorf("Count this(%v) Not Equal that(%v)", this.Count, that1.Count)
	}
	if this.Seq != that1.Seq {
		return fmt.Errorf("Seq this(%v) Not Equal that(%v)", this.Seq, that1.Seq)
	}
	if len(this.Deps) != len(that1.Deps) {
		return fmt.Errorf("Deps this(%v) Not Equal that(%v)", len(this.Deps), len(that1.Deps))
	}
	for i := range this.Deps {
		if this.Deps[i] != that1.Deps[i] {
			return fmt.Errorf("Deps this[%v](%v) Not Equal that[%v](%v)", i, this.Deps[i], i, that1.Deps[i])
		}
	}
	return nil
}
func (this *CommitShort) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CommitShort)
	if !ok {
		that2, ok := that.(CommitShort)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.LeaderId != that1.LeaderId {
		return false
	}
	if this.Replica != that1.Replica {
		return false
	}
	if this.Instance != that1.Instance {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	if this.Seq != that1.Seq {
		return false
	}
	if len(this.Deps) != len(that1.Deps) {
		return false
	}
	for i := range this.Deps {
		if this.Deps[i] != that1.Deps[i] {
			return false
		}
	}
	return true
}
func (this *Command) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Command)
	if !ok {
		that2, ok := that.(Command)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Command")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Command but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Command but is not nil && this == nil")
	}
	if this.Op != that1.Op {
		return fmt.Errorf("Op this(%v) Not Equal that(%v)", this.Op, that1.Op)
	}
	if this.K != that1.K {
		return fmt.Errorf("K this(%v) Not Equal that(%v)", this.K, that1.K)
	}
	if this.V != that1.V {
		return fmt.Errorf("V this(%v) Not Equal that(%v)", this.V, that1.V)
	}
	return nil
}
func (this *Command) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Command)
	if !ok {
		that2, ok := that.(Command)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Op != that1.Op {
		return false
	}
	if this.K != that1.K {
		return false
	}
	if this.V != that1.V {
		return false
	}
	return true
}
func (this *Empty) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Empty)
	if !ok {
		that2, ok := that.(Empty)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Empty")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Empty but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Empty but is not nil && this == nil")
	}
	return nil
}
func (this *Empty) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Empty)
	if !ok {
		that2, ok := that.(Empty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}

/* 'gorums' plugin for protoc-gen-go - generated from: config_rpc_tmpl */

// AcceptRPCReply encapsulates the reply from a AcceptRPC RPC invocation.
// It contains the id of each node in the quorum that replied and a single
// reply.
type AcceptRPCReply struct {
	NodeIDs []uint32
	Reply   *AcceptReply
}

func (r AcceptRPCReply) String() string {
	return fmt.Sprintf("node ids: %v | answer: %v", r.NodeIDs, r.Reply)
}

// AcceptRPC invokes a AcceptRPC RPC on configuration c
// and returns the result as a AcceptRPCReply.
func (c *Configuration) AcceptRPC(args *Accept) (*AcceptRPCReply, error) {
	return c.mgr.acceptRPC(c, args)
}

// AcceptRPCFuture is a reference to an asynchronous AcceptRPC RPC invocation.
type AcceptRPCFuture struct {
	reply *AcceptRPCReply
	err   error
	c     chan struct{}
}

// AcceptRPCFuture asynchronously invokes a AcceptRPC RPC on configuration c and
// returns a AcceptRPCFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) AcceptRPCFuture(args *Accept) *AcceptRPCFuture {
	f := new(AcceptRPCFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.acceptRPC(c, args)
	}()
	return f
}

// Get returns the reply and any error associated with the AcceptRPCFuture.
// The method blocks until a reply or error is available.
func (f *AcceptRPCFuture) Get() (*AcceptRPCReply, error) {
	<-f.c
	return f.reply, f.err
}

// Done reports if a reply or error is available for the AcceptRPCFuture.
func (f *AcceptRPCFuture) Done() bool {
	select {
	case <-f.c:
		return true
	default:
		return false
	}
}

// PreAcceptRPCReply encapsulates the reply from a PreAcceptRPC RPC invocation.
// It contains the id of each node in the quorum that replied and a single
// reply.
type PreAcceptRPCReply struct {
	NodeIDs []uint32
	Reply   *PreAcceptReply
}

func (r PreAcceptRPCReply) String() string {
	return fmt.Sprintf("node ids: %v | answer: %v", r.NodeIDs, r.Reply)
}

// PreAcceptRPC invokes a PreAcceptRPC RPC on configuration c
// and returns the result as a PreAcceptRPCReply.
func (c *Configuration) PreAcceptRPC(args *PreAccept) (*PreAcceptRPCReply, error) {
	return c.mgr.preAcceptRPC(c, args)
}

// PreAcceptRPCFuture is a reference to an asynchronous PreAcceptRPC RPC invocation.
type PreAcceptRPCFuture struct {
	reply *PreAcceptRPCReply
	err   error
	c     chan struct{}
}

// PreAcceptRPCFuture asynchronously invokes a PreAcceptRPC RPC on configuration c and
// returns a PreAcceptRPCFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) PreAcceptRPCFuture(args *PreAccept) *PreAcceptRPCFuture {
	f := new(PreAcceptRPCFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.preAcceptRPC(c, args)
	}()
	return f
}

// Get returns the reply and any error associated with the PreAcceptRPCFuture.
// The method blocks until a reply or error is available.
func (f *PreAcceptRPCFuture) Get() (*PreAcceptRPCReply, error) {
	<-f.c
	return f.reply, f.err
}

// Done reports if a reply or error is available for the PreAcceptRPCFuture.
func (f *PreAcceptRPCFuture) Done() bool {
	select {
	case <-f.c:
		return true
	default:
		return false
	}
}

// CommitRPC invokes an asynchronous CommitRPC RPC on configuration c.
// The call has no return value and is invoked on every node in the
// configuration.
func (c *Configuration) CommitRPC(args *Commit) error {
	return c.mgr.commitRPC(c, args)
}

// CommitShortRPC invokes an asynchronous CommitShortRPC RPC on configuration c.
// The call has no return value and is invoked on every node in the
// configuration.
func (c *Configuration) CommitShortRPC(args *CommitShort) error {
	return c.mgr.commitShortRPC(c, args)
}

/* 'gorums' plugin for protoc-gen-go - generated from: mgr_rpc_tmpl */

type acceptRPCReply struct {
	nid   uint32
	reply *AcceptReply
	err   error
}

func (m *Manager) acceptRPC(c *Configuration, args *Accept) (*AcceptRPCReply, error) {
	replyChan := make(chan acceptRPCReply, c.n)
	ctx, cancel := context.WithCancel(context.Background())

	for _, n := range c.nodes {
		go callGRPCAcceptRPC(n, ctx, args, replyChan)
	}

	var (
		replyValues = make([]*AcceptReply, 0, c.n)
		reply       = &AcceptRPCReply{NodeIDs: make([]uint32, 0, c.n)}
		errCount    int
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}
			replyValues = append(replyValues, r.reply)
			reply.NodeIDs = append(reply.NodeIDs, r.nid)
			if reply.Reply, quorum = c.qspec.AcceptRPCQF(replyValues); quorum {
				cancel()
				return reply, nil
			}
		case <-time.After(c.timeout):
			cancel()
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.n {
			cancel()
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

func callGRPCAcceptRPC(node *Node, ctx context.Context, args *Accept, replyChan chan<- acceptRPCReply) {
	reply := new(AcceptReply)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/epaxosprotobuf.AcceptService/AcceptRPC",
		args,
		reply,
		node.conn,
	)
	switch grpc.Code(err) { // nil -> codes.OK
	case codes.OK, codes.Canceled:
		node.setLatency(time.Since(start))
	default:
		node.setLastErr(err)
	}
	replyChan <- acceptRPCReply{node.id, reply, err}
}

type preAcceptRPCReply struct {
	nid   uint32
	reply *PreAcceptReply
	err   error
}

func (m *Manager) preAcceptRPC(c *Configuration, args *PreAccept) (*PreAcceptRPCReply, error) {
	replyChan := make(chan preAcceptRPCReply, c.n)
	ctx, cancel := context.WithCancel(context.Background())

	for _, n := range c.nodes {
		go callGRPCPreAcceptRPC(n, ctx, args, replyChan)
	}

	var (
		replyValues = make([]*PreAcceptReply, 0, c.n)
		reply       = &PreAcceptRPCReply{NodeIDs: make([]uint32, 0, c.n)}
		errCount    int
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}
			replyValues = append(replyValues, r.reply)
			reply.NodeIDs = append(reply.NodeIDs, r.nid)
			if reply.Reply, quorum = c.qspec.PreAcceptRPCQF(replyValues); quorum {
				cancel()
				return reply, nil
			}
		case <-time.After(c.timeout):
			cancel()
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.n {
			cancel()
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

func callGRPCPreAcceptRPC(node *Node, ctx context.Context, args *PreAccept, replyChan chan<- preAcceptRPCReply) {
	reply := new(PreAcceptReply)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/epaxosprotobuf.AcceptService/PreAcceptRPC",
		args,
		reply,
		node.conn,
	)
	switch grpc.Code(err) { // nil -> codes.OK
	case codes.OK, codes.Canceled:
		node.setLatency(time.Since(start))
	default:
		node.setLastErr(err)
	}
	replyChan <- preAcceptRPCReply{node.id, reply, err}
}

func (m *Manager) commitRPC(c *Configuration, args *Commit) error {
	for _, node := range c.nodes {
		go func(n *Node) {
			err := n.commitRPCClient.Send(args)
			if err == nil {
				return
			}
			if m.logger != nil {
				m.logger.Printf("%d: commitRPC stream send error: %v", n.id, err)
			}
		}(node)
	}

	return nil
}

func (m *Manager) commitShortRPC(c *Configuration, args *CommitShort) error {
	for _, node := range c.nodes {
		go func(n *Node) {
			err := n.commitShortRPCClient.Send(args)
			if err == nil {
				return
			}
			if m.logger != nil {
				m.logger.Printf("%d: commitShortRPC stream send error: %v", n.id, err)
			}
		}(node)
	}

	return nil
}

/* 'gorums' plugin for protoc-gen-go - generated from: node_tmpl */

// Node encapsulates the state of a node on which a remote procedure call
// can be made.
type Node struct {
	// Only assigned at creation.
	id   uint32
	self bool
	addr string
	conn *grpc.ClientConn

	commitRPCClient CommitService_CommitRPCClient

	commitShortRPCClient CommitService_CommitShortRPCClient

	sync.Mutex
	lastErr error
	latency time.Duration
}

func (n *Node) connect(opts ...grpc.DialOption) error {
	var err error
	n.conn, err = grpc.Dial(n.addr, opts...)
	if err != nil {
		return fmt.Errorf("dialing node failed: %v", err)
	}

	clientCommitService := NewCommitServiceClient(n.conn)

	n.commitRPCClient, err = clientCommitService.CommitRPC(context.Background())
	if err != nil {
		return fmt.Errorf("stream creation failed: %v", err)
	}

	n.commitShortRPCClient, err = clientCommitService.CommitShortRPC(context.Background())
	if err != nil {
		return fmt.Errorf("stream creation failed: %v", err)
	}

	return nil
}

func (n *Node) close() error {
	var err error
	_, err = n.commitRPCClient.CloseAndRecv()
	_, err = n.commitShortRPCClient.CloseAndRecv()
	err2 := n.conn.Close()
	if err != nil {
		return fmt.Errorf("stream close failed: %v", err)
	} else if err2 != nil {
		return fmt.Errorf("conn close failed: %v", err2)
	}
	return nil
}

/* 'gorums' plugin for protoc-gen-go - generated from: qspec_tmpl */

// QuorumSpec is the interface that wraps every quorum function.
type QuorumSpec interface {
	// AcceptRPCQF is the quorum function for the AcceptRPC RPC method.
	AcceptRPCQF(replies []*AcceptReply) (*AcceptReply, bool)
	// PreAcceptRPCQF is the quorum function for the PreAcceptRPC RPC method.
	PreAcceptRPCQF(replies []*PreAcceptReply) (*PreAcceptReply, bool)
}

/* Static resources */

/* config.go */

// A Configuration represents a static set of nodes on which quorum remote
// procedure calls may be invoked.
type Configuration struct {
	id      uint32
	nodes   []*Node
	n       int
	mgr     *Manager
	timeout time.Duration
	qspec   QuorumSpec
}

// ID reports the identifier for the configuration.
func (c *Configuration) ID() uint32 {
	return c.id
}

// NodeIDs returns a slice containing the local ids of all the nodes in the
// configuration.
func (c *Configuration) NodeIDs() []uint32 {
	ids := make([]uint32, len(c.nodes))
	for i, node := range c.nodes {
		ids[i] = node.ID()
	}
	return ids
}

// Size returns the number of nodes in the configuration.
func (c *Configuration) Size() int {
	return c.n
}

func (c *Configuration) String() string {
	return fmt.Sprintf("configuration %d", c.id)
}

// Equal returns a boolean reporting whether a and b represents the same
// configuration.
func Equal(a, b *Configuration) bool { return a.id == b.id }

// NewTestConfiguration returns a new configuration with quorum size q and
// node size n. No other fields are set. Configurations returned from this
// constructor should only be used when testing quorum functions.
func NewTestConfiguration(q, n int) *Configuration {
	return &Configuration{
		nodes: make([]*Node, n),
	}
}

/* errors.go */

// A NodeNotFoundError reports that a specified node could not be found.
type NodeNotFoundError uint32

func (e NodeNotFoundError) Error() string {
	return fmt.Sprintf("node not found: %d", e)
}

// A ConfigNotFoundError reports that a specified configuration could not be
// found.
type ConfigNotFoundError uint32

func (e ConfigNotFoundError) Error() string {
	return fmt.Sprintf("configuration not found: %d", e)
}

// An IncompleteRPCError reports that a quorum RPC call failed.
type IncompleteRPCError struct {
	ErrCount, ReplyCount int
}

func (e IncompleteRPCError) Error() string {
	return fmt.Sprintf(
		"incomplete rpc (errors: %d, replies: %d)",
		e.ErrCount, e.ReplyCount,
	)
}

// An TimeoutRPCError reports that a quorum RPC call timed out.
type TimeoutRPCError struct {
	Waited                 time.Duration
	ErrCount, RepliesCount int
}

func (e TimeoutRPCError) Error() string {
	return fmt.Sprintf(
		"rpc timed out: waited %v (errors: %d, replies: %d)",
		e.Waited, e.ErrCount, e.RepliesCount,
	)
}

// An IllegalConfigError reports that a specified configuration could not be
// created.
type IllegalConfigError string

func (e IllegalConfigError) Error() string {
	return "illegal configuration: " + string(e)
}

// ManagerCreationError returns an error reporting that a Manager could not be
// created due to err.
func ManagerCreationError(err error) error {
	return fmt.Errorf("could not create manager: %s", err.Error())
}

/* mgr.go */

// Manager manages a pool of node configurations on which quorum remote
// procedure calls can be made.
type Manager struct {
	sync.RWMutex

	nodes   map[uint32]*Node
	configs map[uint32]*Configuration

	closeOnce sync.Once
	logger    *log.Logger
	opts      managerOptions
}

// NewManager attempts to connect to the given set of node addresses and if
// successful returns a new Manager containing connections to those nodes.
func NewManager(nodeAddrs []string, opts ...ManagerOption) (*Manager, error) {
	if len(nodeAddrs) == 0 {
		return nil, fmt.Errorf("could not create manager: no nodes provided")
	}

	m := &Manager{
		nodes:   make(map[uint32]*Node),
		configs: make(map[uint32]*Configuration),
	}

	for _, opt := range opts {
		opt(&m.opts)
	}

	selfAddrIndex, selfID, err := m.parseSelfOptions(nodeAddrs)
	if err != nil {
		return nil, ManagerCreationError(err)
	}

	idSeen := false
	for i, naddr := range nodeAddrs {
		node, err2 := m.createNode(naddr)
		if err2 != nil {
			return nil, ManagerCreationError(err2)
		}
		m.nodes[node.id] = node
		if i == selfAddrIndex {
			node.self = true
			continue
		}
		if node.id == selfID {
			node.self = true
			idSeen = true
		}
	}
	if selfID != 0 && !idSeen {
		return nil, ManagerCreationError(
			fmt.Errorf("WithSelfID provided, but no node with id %d found", selfID),
		)
	}

	err = m.connectAll()
	if err != nil {
		return nil, ManagerCreationError(err)
	}

	if m.opts.logger != nil {
		m.logger = m.opts.logger
	}

	return m, nil
}

func (m *Manager) parseSelfOptions(addrs []string) (int, uint32, error) {
	if m.opts.selfAddr != "" && m.opts.selfID != 0 {
		return 0, 0, fmt.Errorf("both WithSelfAddr and WithSelfID provided")
	}
	if m.opts.selfID != 0 {
		return -1, m.opts.selfID, nil
	}
	if m.opts.selfAddr == "" {
		return -1, 0, nil
	}

	seen, index := contains(m.opts.selfAddr, addrs)
	if !seen {
		return 0, 0, fmt.Errorf(
			"option WithSelfAddr provided, but address %q was not present in address list",
			m.opts.selfAddr)
	}

	return index, 0, nil
}

func (m *Manager) createNode(addr string) (*Node, error) {
	m.Lock()
	defer m.Unlock()

	tcpAddr, err := net.ResolveTCPAddr("tcp", addr)
	if err != nil {
		return nil, fmt.Errorf("create node %s error: %v", addr, err)
	}

	h := fnv.New32a()
	_, _ = h.Write([]byte(tcpAddr.String()))
	id := h.Sum32()

	if _, found := m.nodes[id]; found {
		return nil, fmt.Errorf("create node %s error: node already exists", addr)
	}

	node := &Node{
		id:      id,
		addr:    tcpAddr.String(),
		latency: -1 * time.Second,
	}

	return node, nil
}

func (m *Manager) connectAll() error {
	if m.opts.noConnect {
		return nil
	}
	for _, node := range m.nodes {
		if node.self {
			continue
		}
		err := node.connect(m.opts.grpcDialOpts...)
		if err != nil {
			return fmt.Errorf("connect node %s error: %v", node.addr, err)
		}
	}
	return nil
}

func (m *Manager) closeNodeConns() {
	for _, node := range m.nodes {
		if node.self {
			continue
		}
		err := node.close()
		if err == nil {
			continue
		}
		if m.logger != nil {
			m.logger.Printf("node %d: error closing: %v", node.id, err)
		}
	}
}

// Close closes all node connections and any client streams.
func (m *Manager) Close() {
	m.closeOnce.Do(func() {
		m.closeNodeConns()
	})
}

// NodeIDs returns the identifier of each available node.
func (m *Manager) NodeIDs() []uint32 {
	m.RLock()
	defer m.RUnlock()
	ids := make([]uint32, 0, len(m.nodes))
	for id := range m.nodes {
		ids = append(ids, id)
	}
	sort.Sort(idSlice(ids))
	return ids
}

// Node returns the node with the given identifier if present.
func (m *Manager) Node(id uint32) (node *Node, found bool) {
	m.RLock()
	defer m.RUnlock()
	node, found = m.nodes[id]
	return node, found
}

// Nodes returns a slice of each available node.
func (m *Manager) Nodes(excludeSelf bool) []*Node {
	m.RLock()
	defer m.RUnlock()
	var nodes []*Node
	for _, node := range m.nodes {
		if excludeSelf && node.self {
			continue
		}
		nodes = append(nodes, node)
	}
	OrderedBy(ID).Sort(nodes)
	return nodes
}

// ConfigurationIDs returns the identifier of each available
// configuration.
func (m *Manager) ConfigurationIDs() []uint32 {
	m.RLock()
	defer m.RUnlock()
	ids := make([]uint32, 0, len(m.configs))
	for id := range m.configs {
		ids = append(ids, id)
	}
	sort.Sort(idSlice(ids))
	return ids
}

// Configuration returns the configuration with the given global
// identifier if present.
func (m *Manager) Configuration(id uint32) (config *Configuration, found bool) {
	m.RLock()
	defer m.RUnlock()
	config, found = m.configs[id]
	return config, found
}

// Configurations returns a slice of each available configuration.
func (m *Manager) Configurations() []*Configuration {
	m.RLock()
	defer m.RUnlock()
	configs := make([]*Configuration, 0, len(m.configs))
	for _, conf := range m.configs {
		configs = append(configs, conf)
	}
	return configs
}

// Size returns the number of nodes and configurations in the Manager.
func (m *Manager) Size() (nodes, configs int) {
	m.RLock()
	defer m.RUnlock()
	return len(m.nodes), len(m.configs)
}

// AddNode attempts to dial to the provide node address. The node is
// added to the Manager's pool of nodes if a connection was established.
func (m *Manager) AddNode(addr string) error {
	panic("not implemented")
}

// NewConfiguration returns a new configuration given quorum specification and
// a timeout.
func (m *Manager) NewConfiguration(ids []uint32, qspec QuorumSpec, timeout time.Duration) (*Configuration, error) {
	m.Lock()
	defer m.Unlock()

	if len(ids) == 0 {
		return nil, IllegalConfigError("need at least one node")
	}
	if timeout <= 0 {
		return nil, IllegalConfigError("timeout must be positive")
	}

	var cnodes []*Node
	for _, nid := range ids {
		node, found := m.nodes[nid]
		if !found {
			return nil, NodeNotFoundError(nid)
		}
		if node.self && m.selfSpecified() {
			return nil, IllegalConfigError(
				fmt.Sprintf("self (%d) can't be part of a configuration when a self-option is provided", nid),
			)
		}
		cnodes = append(cnodes, node)
	}

	// Node ids are sorted ensure a globally consistent configuration id.
	OrderedBy(ID).Sort(cnodes)

	h := fnv.New32a()
	binary.Write(h, binary.LittleEndian, timeout)
	for _, node := range cnodes {
		binary.Write(h, binary.LittleEndian, node.id)
	}
	cid := h.Sum32()

	conf, found := m.configs[cid]
	if found {
		return conf, nil
	}

	c := &Configuration{
		id:      cid,
		nodes:   cnodes,
		n:       len(cnodes),
		mgr:     m,
		qspec:   qspec,
		timeout: timeout,
	}
	m.configs[cid] = c

	return c, nil
}

func (m *Manager) selfSpecified() bool {
	return m.opts.selfAddr != "" || m.opts.selfID != 0
}

type idSlice []uint32

func (p idSlice) Len() int           { return len(p) }
func (p idSlice) Less(i, j int) bool { return p[i] < p[j] }
func (p idSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }

/* node_func.go */

// ID returns the ID of m.
func (n *Node) ID() uint32 {
	return n.id
}

// Address returns network address of m.
func (n *Node) Address() string {
	return n.addr
}

func (n *Node) String() string {
	n.Lock()
	defer n.Unlock()
	return fmt.Sprintf(
		"node %d | addr: %s | latency: %v",
		n.id, n.addr, n.latency,
	)
}

func (n *Node) setLastErr(err error) {
	n.Lock()
	defer n.Unlock()
	n.lastErr = err
}

// LastErr returns the last error encountered (if any) when invoking a remote
// procedure call on this node.
func (n *Node) LastErr() error {
	n.Lock()
	defer n.Unlock()
	return n.lastErr
}

func (n *Node) setLatency(lat time.Duration) {
	n.Lock()
	defer n.Unlock()
	n.latency = lat
}

// Latency returns the latency of the last successful remote procedure call
// made to this node.
func (n *Node) Latency() time.Duration {
	n.Lock()
	defer n.Unlock()
	return n.latency
}

type lessFunc func(n1, n2 *Node) bool

// MultiSorter implements the Sort interface, sorting the nodes within.
type MultiSorter struct {
	nodes []*Node
	less  []lessFunc
}

// Sort sorts the argument slice according to the less functions passed to
// OrderedBy.
func (ms *MultiSorter) Sort(nodes []*Node) {
	ms.nodes = nodes
	sort.Sort(ms)
}

// OrderedBy returns a Sorter that sorts using the less functions, in order.
// Call its Sort method to sort the data.
func OrderedBy(less ...lessFunc) *MultiSorter {
	return &MultiSorter{
		less: less,
	}
}

// Len is part of sort.Interface.
func (ms *MultiSorter) Len() int {
	return len(ms.nodes)
}

// Swap is part of sort.Interface.
func (ms *MultiSorter) Swap(i, j int) {
	ms.nodes[i], ms.nodes[j] = ms.nodes[j], ms.nodes[i]
}

// Less is part of sort.Interface. It is implemented by looping along the
// less functions until it finds a comparison that is either Less or
// !Less. Note that it can call the less functions twice per call. We
// could change the functions to return -1, 0, 1 and reduce the
// number of calls for greater efficiency: an exercise for the reader.
func (ms *MultiSorter) Less(i, j int) bool {
	p, q := ms.nodes[i], ms.nodes[j]
	// Try all but the last comparison.
	var k int
	for k = 0; k < len(ms.less)-1; k++ {
		less := ms.less[k]
		switch {
		case less(p, q):
			// p < q, so we have a decision.
			return true
		case less(q, p):
			// p > q, so we have a decision.
			return false
		}
		// p == q; try the next comparison.
	}
	// All comparisons to here said "equal", so just return whatever
	// the final comparison reports.
	return ms.less[k](p, q)
}

// ID sorts nodes by their identifier in increasing order.
var ID = func(n1, n2 *Node) bool {
	return n1.id < n2.id
}

// Latency sorts nodes by latency in increasing order. Latencies less then
// zero (sentinel value) are considered greater than any positive latency.
var Latency = func(n1, n2 *Node) bool {
	if n1.latency < 0 {
		return false
	}
	return n1.latency < n2.latency

}

// Error sorts nodes by their LastErr() status in increasing order. A
// node with LastErr() != nil is larger than a node with LastErr() == nil.
var Error = func(n1, n2 *Node) bool {
	if n1.lastErr != nil && n2.lastErr == nil {
		return false
	}
	return true
}

/* opts.go */

type managerOptions struct {
	grpcDialOpts []grpc.DialOption
	logger       *log.Logger
	noConnect    bool
	selfAddr     string
	selfID       uint32
}

// ManagerOption provides a way to set different options on a new Manager.
type ManagerOption func(*managerOptions)

// WithGrpcDialOptions returns a ManagerOption which sets any gRPC dial options
// the Manager should use when initially connecting to each node in its
// pool.
func WithGrpcDialOptions(opts ...grpc.DialOption) ManagerOption {
	return func(o *managerOptions) {
		o.grpcDialOpts = opts
	}
}

// WithLogger returns a ManagerOption which sets an optional error logger for
// the Manager.
func WithLogger(logger *log.Logger) ManagerOption {
	return func(o *managerOptions) {
		o.logger = logger
	}
}

// WithNoConnect returns a ManagerOption which instructs the Manager not to
// connect to any of its nodes. Mainly used for testing purposes.
func WithNoConnect() ManagerOption {
	return func(o *managerOptions) {
		o.noConnect = true
	}
}

// WithSelfAddr returns a ManagerOption which instructs the Manager not to connect
// to the node with network address addr. The address must be present in the
// list of node addresses provided to the Manager.
func WithSelfAddr(addr string) ManagerOption {
	return func(o *managerOptions) {
		o.selfAddr = addr
	}
}

// WithSelfID returns a ManagerOption which instructs the Manager not to
// connect to the node with the given id. The node must be present in the list
// of node addresses provided to the Manager.
func WithSelfID(id uint32) ManagerOption {
	return func(o *managerOptions) {
		o.selfID = id
	}
}

/* util.go */

func contains(addr string, addrs []string) (found bool, index int) {
	for i, a := range addrs {
		if addr == a {
			return true, i
		}
	}
	return false, -1
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for AcceptService service

type AcceptServiceClient interface {
	PreAcceptRPC(ctx context.Context, in *PreAccept, opts ...grpc.CallOption) (*PreAcceptReply, error)
	AcceptRPC(ctx context.Context, in *Accept, opts ...grpc.CallOption) (*AcceptReply, error)
}

type acceptServiceClient struct {
	cc *grpc.ClientConn
}

func NewAcceptServiceClient(cc *grpc.ClientConn) AcceptServiceClient {
	return &acceptServiceClient{cc}
}

func (c *acceptServiceClient) PreAcceptRPC(ctx context.Context, in *PreAccept, opts ...grpc.CallOption) (*PreAcceptReply, error) {
	out := new(PreAcceptReply)
	err := grpc.Invoke(ctx, "/epaxosprotobuf.AcceptService/PreAcceptRPC", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *acceptServiceClient) AcceptRPC(ctx context.Context, in *Accept, opts ...grpc.CallOption) (*AcceptReply, error) {
	out := new(AcceptReply)
	err := grpc.Invoke(ctx, "/epaxosprotobuf.AcceptService/AcceptRPC", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AcceptService service

type AcceptServiceServer interface {
	PreAcceptRPC(context.Context, *PreAccept) (*PreAcceptReply, error)
	AcceptRPC(context.Context, *Accept) (*AcceptReply, error)
}

func RegisterAcceptServiceServer(s *grpc.Server, srv AcceptServiceServer) {
	s.RegisterService(&_AcceptService_serviceDesc, srv)
}

func _AcceptService_PreAcceptRPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PreAccept)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcceptServiceServer).PreAcceptRPC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/epaxosprotobuf.AcceptService/PreAcceptRPC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcceptServiceServer).PreAcceptRPC(ctx, req.(*PreAccept))
	}
	return interceptor(ctx, in, info, handler)
}

func _AcceptService_AcceptRPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Accept)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcceptServiceServer).AcceptRPC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/epaxosprotobuf.AcceptService/AcceptRPC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcceptServiceServer).AcceptRPC(ctx, req.(*Accept))
	}
	return interceptor(ctx, in, info, handler)
}

var _AcceptService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "epaxosprotobuf.AcceptService",
	HandlerType: (*AcceptServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PreAcceptRPC",
			Handler:    _AcceptService_PreAcceptRPC_Handler,
		},
		{
			MethodName: "AcceptRPC",
			Handler:    _AcceptService_AcceptRPC_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptorEpaxos,
}

// Client API for CommitService service

type CommitServiceClient interface {
	CommitRPC(ctx context.Context, opts ...grpc.CallOption) (CommitService_CommitRPCClient, error)
	CommitShortRPC(ctx context.Context, opts ...grpc.CallOption) (CommitService_CommitShortRPCClient, error)
}

type commitServiceClient struct {
	cc *grpc.ClientConn
}

func NewCommitServiceClient(cc *grpc.ClientConn) CommitServiceClient {
	return &commitServiceClient{cc}
}

func (c *commitServiceClient) CommitRPC(ctx context.Context, opts ...grpc.CallOption) (CommitService_CommitRPCClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CommitService_serviceDesc.Streams[0], c.cc, "/epaxosprotobuf.CommitService/CommitRPC", opts...)
	if err != nil {
		return nil, err
	}
	x := &commitServiceCommitRPCClient{stream}
	return x, nil
}

type CommitService_CommitRPCClient interface {
	Send(*Commit) error
	CloseAndRecv() (*Empty, error)
	grpc.ClientStream
}

type commitServiceCommitRPCClient struct {
	grpc.ClientStream
}

func (x *commitServiceCommitRPCClient) Send(m *Commit) error {
	return x.ClientStream.SendMsg(m)
}

func (x *commitServiceCommitRPCClient) CloseAndRecv() (*Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *commitServiceClient) CommitShortRPC(ctx context.Context, opts ...grpc.CallOption) (CommitService_CommitShortRPCClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CommitService_serviceDesc.Streams[1], c.cc, "/epaxosprotobuf.CommitService/CommitShortRPC", opts...)
	if err != nil {
		return nil, err
	}
	x := &commitServiceCommitShortRPCClient{stream}
	return x, nil
}

type CommitService_CommitShortRPCClient interface {
	Send(*CommitShort) error
	CloseAndRecv() (*Empty, error)
	grpc.ClientStream
}

type commitServiceCommitShortRPCClient struct {
	grpc.ClientStream
}

func (x *commitServiceCommitShortRPCClient) Send(m *CommitShort) error {
	return x.ClientStream.SendMsg(m)
}

func (x *commitServiceCommitShortRPCClient) CloseAndRecv() (*Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for CommitService service

type CommitServiceServer interface {
	CommitRPC(CommitService_CommitRPCServer) error
	CommitShortRPC(CommitService_CommitShortRPCServer) error
}

func RegisterCommitServiceServer(s *grpc.Server, srv CommitServiceServer) {
	s.RegisterService(&_CommitService_serviceDesc, srv)
}

func _CommitService_CommitRPC_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CommitServiceServer).CommitRPC(&commitServiceCommitRPCServer{stream})
}

type CommitService_CommitRPCServer interface {
	SendAndClose(*Empty) error
	Recv() (*Commit, error)
	grpc.ServerStream
}

type commitServiceCommitRPCServer struct {
	grpc.ServerStream
}

func (x *commitServiceCommitRPCServer) SendAndClose(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *commitServiceCommitRPCServer) Recv() (*Commit, error) {
	m := new(Commit)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _CommitService_CommitShortRPC_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CommitServiceServer).CommitShortRPC(&commitServiceCommitShortRPCServer{stream})
}

type CommitService_CommitShortRPCServer interface {
	SendAndClose(*Empty) error
	Recv() (*CommitShort, error)
	grpc.ServerStream
}

type commitServiceCommitShortRPCServer struct {
	grpc.ServerStream
}

func (x *commitServiceCommitShortRPCServer) SendAndClose(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *commitServiceCommitShortRPCServer) Recv() (*CommitShort, error) {
	m := new(CommitShort)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _CommitService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "epaxosprotobuf.CommitService",
	HandlerType: (*CommitServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CommitRPC",
			Handler:       _CommitService_CommitRPC_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "CommitShortRPC",
			Handler:       _CommitService_CommitShortRPC_Handler,
			ClientStreams: true,
		},
	},
	Metadata: fileDescriptorEpaxos,
}

func (m *PreAccept) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PreAccept) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LeaderId != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.LeaderId))
	}
	if m.Replica != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Instance))
	}
	if m.Ballot != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Ballot))
	}
	if m.Seq != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		for _, num := range m.Deps {
			data[i] = 0x30
			i++
			i = encodeVarintEpaxos(data, i, uint64(num))
		}
	}
	if len(m.Command) > 0 {
		for _, msg := range m.Command {
			data[i] = 0x3a
			i++
			i = encodeVarintEpaxos(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PreAcceptReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PreAcceptReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Replica != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Instance))
	}
	if m.Ok != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Ok))
	}
	if m.Ballot != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Ballot))
	}
	if m.Seq != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		for _, num := range m.Deps {
			data[i] = 0x30
			i++
			i = encodeVarintEpaxos(data, i, uint64(num))
		}
	}
	if len(m.CommittedDeps) > 0 {
		for _, num := range m.CommittedDeps {
			data[i] = 0x38
			i++
			i = encodeVarintEpaxos(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *PreAcceptOK) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PreAcceptOK) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Instance != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Instance))
	}
	return i, nil
}

func (m *Accept) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Accept) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LeaderId != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.LeaderId))
	}
	if m.Replica != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Instance))
	}
	if m.Ballot != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Ballot))
	}
	if m.Count != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Count))
	}
	if m.Seq != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		for _, num := range m.Deps {
			data[i] = 0x38
			i++
			i = encodeVarintEpaxos(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *AcceptReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AcceptReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Replica != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Instance))
	}
	if m.Ok != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Ok))
	}
	if m.Ballot != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Ballot))
	}
	return i, nil
}

func (m *Commit) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Commit) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LeaderId != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.LeaderId))
	}
	if m.Replica != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Instance))
	}
	if len(m.Command) > 0 {
		for _, msg := range m.Command {
			data[i] = 0x22
			i++
			i = encodeVarintEpaxos(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Seq != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		for _, num := range m.Deps {
			data[i] = 0x30
			i++
			i = encodeVarintEpaxos(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *CommitShort) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CommitShort) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LeaderId != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.LeaderId))
	}
	if m.Replica != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Instance))
	}
	if m.Count != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Count))
	}
	if m.Seq != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		for _, num := range m.Deps {
			data[i] = 0x30
			i++
			i = encodeVarintEpaxos(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *Command) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Command) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Op))
	}
	if m.K != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.K))
	}
	if m.V != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.V))
	}
	return i, nil
}

func (m *Empty) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Empty) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeFixed64Epaxos(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Epaxos(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintEpaxos(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *PreAccept) Size() (n int) {
	var l int
	_ = l
	if m.LeaderId != 0 {
		n += 1 + sovEpaxos(uint64(m.LeaderId))
	}
	if m.Replica != 0 {
		n += 1 + sovEpaxos(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovEpaxos(uint64(m.Instance))
	}
	if m.Ballot != 0 {
		n += 1 + sovEpaxos(uint64(m.Ballot))
	}
	if m.Seq != 0 {
		n += 1 + sovEpaxos(uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		for _, e := range m.Deps {
			n += 1 + sovEpaxos(uint64(e))
		}
	}
	if len(m.Command) > 0 {
		for _, e := range m.Command {
			l = e.Size()
			n += 1 + l + sovEpaxos(uint64(l))
		}
	}
	return n
}

func (m *PreAcceptReply) Size() (n int) {
	var l int
	_ = l
	if m.Replica != 0 {
		n += 1 + sovEpaxos(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovEpaxos(uint64(m.Instance))
	}
	if m.Ok != 0 {
		n += 1 + sovEpaxos(uint64(m.Ok))
	}
	if m.Ballot != 0 {
		n += 1 + sovEpaxos(uint64(m.Ballot))
	}
	if m.Seq != 0 {
		n += 1 + sovEpaxos(uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		for _, e := range m.Deps {
			n += 1 + sovEpaxos(uint64(e))
		}
	}
	if len(m.CommittedDeps) > 0 {
		for _, e := range m.CommittedDeps {
			n += 1 + sovEpaxos(uint64(e))
		}
	}
	return n
}

func (m *PreAcceptOK) Size() (n int) {
	var l int
	_ = l
	if m.Instance != 0 {
		n += 1 + sovEpaxos(uint64(m.Instance))
	}
	return n
}

func (m *Accept) Size() (n int) {
	var l int
	_ = l
	if m.LeaderId != 0 {
		n += 1 + sovEpaxos(uint64(m.LeaderId))
	}
	if m.Replica != 0 {
		n += 1 + sovEpaxos(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovEpaxos(uint64(m.Instance))
	}
	if m.Ballot != 0 {
		n += 1 + sovEpaxos(uint64(m.Ballot))
	}
	if m.Count != 0 {
		n += 1 + sovEpaxos(uint64(m.Count))
	}
	if m.Seq != 0 {
		n += 1 + sovEpaxos(uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		for _, e := range m.Deps {
			n += 1 + sovEpaxos(uint64(e))
		}
	}
	return n
}

func (m *AcceptReply) Size() (n int) {
	var l int
	_ = l
	if m.Replica != 0 {
		n += 1 + sovEpaxos(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovEpaxos(uint64(m.Instance))
	}
	if m.Ok != 0 {
		n += 1 + sovEpaxos(uint64(m.Ok))
	}
	if m.Ballot != 0 {
		n += 1 + sovEpaxos(uint64(m.Ballot))
	}
	return n
}

func (m *Commit) Size() (n int) {
	var l int
	_ = l
	if m.LeaderId != 0 {
		n += 1 + sovEpaxos(uint64(m.LeaderId))
	}
	if m.Replica != 0 {
		n += 1 + sovEpaxos(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovEpaxos(uint64(m.Instance))
	}
	if len(m.Command) > 0 {
		for _, e := range m.Command {
			l = e.Size()
			n += 1 + l + sovEpaxos(uint64(l))
		}
	}
	if m.Seq != 0 {
		n += 1 + sovEpaxos(uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		for _, e := range m.Deps {
			n += 1 + sovEpaxos(uint64(e))
		}
	}
	return n
}

func (m *CommitShort) Size() (n int) {
	var l int
	_ = l
	if m.LeaderId != 0 {
		n += 1 + sovEpaxos(uint64(m.LeaderId))
	}
	if m.Replica != 0 {
		n += 1 + sovEpaxos(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovEpaxos(uint64(m.Instance))
	}
	if m.Count != 0 {
		n += 1 + sovEpaxos(uint64(m.Count))
	}
	if m.Seq != 0 {
		n += 1 + sovEpaxos(uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		for _, e := range m.Deps {
			n += 1 + sovEpaxos(uint64(e))
		}
	}
	return n
}

func (m *Command) Size() (n int) {
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovEpaxos(uint64(m.Op))
	}
	if m.K != 0 {
		n += 1 + sovEpaxos(uint64(m.K))
	}
	if m.V != 0 {
		n += 1 + sovEpaxos(uint64(m.V))
	}
	return n
}

func (m *Empty) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovEpaxos(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozEpaxos(x uint64) (n int) {
	return sovEpaxos(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *PreAccept) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PreAccept{`,
		`LeaderId:` + fmt.Sprintf("%v", this.LeaderId) + `,`,
		`Replica:` + fmt.Sprintf("%v", this.Replica) + `,`,
		`Instance:` + fmt.Sprintf("%v", this.Instance) + `,`,
		`Ballot:` + fmt.Sprintf("%v", this.Ballot) + `,`,
		`Seq:` + fmt.Sprintf("%v", this.Seq) + `,`,
		`Deps:` + fmt.Sprintf("%v", this.Deps) + `,`,
		`Command:` + strings.Replace(fmt.Sprintf("%v", this.Command), "Command", "Command", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PreAcceptReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PreAcceptReply{`,
		`Replica:` + fmt.Sprintf("%v", this.Replica) + `,`,
		`Instance:` + fmt.Sprintf("%v", this.Instance) + `,`,
		`Ok:` + fmt.Sprintf("%v", this.Ok) + `,`,
		`Ballot:` + fmt.Sprintf("%v", this.Ballot) + `,`,
		`Seq:` + fmt.Sprintf("%v", this.Seq) + `,`,
		`Deps:` + fmt.Sprintf("%v", this.Deps) + `,`,
		`CommittedDeps:` + fmt.Sprintf("%v", this.CommittedDeps) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PreAcceptOK) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PreAcceptOK{`,
		`Instance:` + fmt.Sprintf("%v", this.Instance) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Accept) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Accept{`,
		`LeaderId:` + fmt.Sprintf("%v", this.LeaderId) + `,`,
		`Replica:` + fmt.Sprintf("%v", this.Replica) + `,`,
		`Instance:` + fmt.Sprintf("%v", this.Instance) + `,`,
		`Ballot:` + fmt.Sprintf("%v", this.Ballot) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`Seq:` + fmt.Sprintf("%v", this.Seq) + `,`,
		`Deps:` + fmt.Sprintf("%v", this.Deps) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AcceptReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AcceptReply{`,
		`Replica:` + fmt.Sprintf("%v", this.Replica) + `,`,
		`Instance:` + fmt.Sprintf("%v", this.Instance) + `,`,
		`Ok:` + fmt.Sprintf("%v", this.Ok) + `,`,
		`Ballot:` + fmt.Sprintf("%v", this.Ballot) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Commit) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Commit{`,
		`LeaderId:` + fmt.Sprintf("%v", this.LeaderId) + `,`,
		`Replica:` + fmt.Sprintf("%v", this.Replica) + `,`,
		`Instance:` + fmt.Sprintf("%v", this.Instance) + `,`,
		`Command:` + strings.Replace(fmt.Sprintf("%v", this.Command), "Command", "Command", 1) + `,`,
		`Seq:` + fmt.Sprintf("%v", this.Seq) + `,`,
		`Deps:` + fmt.Sprintf("%v", this.Deps) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CommitShort) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CommitShort{`,
		`LeaderId:` + fmt.Sprintf("%v", this.LeaderId) + `,`,
		`Replica:` + fmt.Sprintf("%v", this.Replica) + `,`,
		`Instance:` + fmt.Sprintf("%v", this.Instance) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`Seq:` + fmt.Sprintf("%v", this.Seq) + `,`,
		`Deps:` + fmt.Sprintf("%v", this.Deps) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Command) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Command{`,
		`Op:` + fmt.Sprintf("%v", this.Op) + `,`,
		`K:` + fmt.Sprintf("%v", this.K) + `,`,
		`V:` + fmt.Sprintf("%v", this.V) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Empty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Empty{`,
		`}`,
	}, "")
	return s
}
func valueToStringEpaxos(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *PreAccept) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreAccept: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreAccept: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderId", wireType)
			}
			m.LeaderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LeaderId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ballot", wireType)
			}
			m.Ballot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ballot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deps", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deps = append(m.Deps, v)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, &Command{})
			if err := m.Command[len(m.Command)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreAcceptReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreAcceptReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreAcceptReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			m.Ok = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ok |= (OK(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ballot", wireType)
			}
			m.Ballot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ballot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deps", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deps = append(m.Deps, v)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedDeps", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CommittedDeps = append(m.CommittedDeps, v)
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreAcceptOK) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreAcceptOK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreAcceptOK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Accept) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Accept: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Accept: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderId", wireType)
			}
			m.LeaderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LeaderId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ballot", wireType)
			}
			m.Ballot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ballot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deps", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deps = append(m.Deps, v)
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			m.Ok = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ok |= (OK(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ballot", wireType)
			}
			m.Ballot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ballot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Commit) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Commit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Commit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderId", wireType)
			}
			m.LeaderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LeaderId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, &Command{})
			if err := m.Command[len(m.Command)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deps", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deps = append(m.Deps, v)
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitShort) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitShort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitShort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderId", wireType)
			}
			m.LeaderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LeaderId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deps", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deps = append(m.Deps, v)
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Command) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Op |= (Command_Operation(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			m.K = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.K |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			m.V = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.V |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEpaxos(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthEpaxos
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowEpaxos
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipEpaxos(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthEpaxos = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEpaxos   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("epaxosprotobuf/epaxos.proto", fileDescriptorEpaxos) }

var fileDescriptorEpaxos = []byte{
	// 665 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xc4, 0x54, 0x3d, 0x6f, 0xd3, 0x50,
	0x14, 0xf5, 0xf3, 0x67, 0x7c, 0xd3, 0x18, 0xeb, 0x09, 0x8a, 0x69, 0x24, 0xab, 0x58, 0x42, 0x0a,
	0x08, 0x05, 0x35, 0xec, 0x48, 0xad, 0x6b, 0x41, 0x49, 0x5b, 0x07, 0x37, 0x15, 0x9d, 0xa8, 0x5c,
	0xe7, 0x21, 0xa2, 0xa4, 0xb1, 0x71, 0xdc, 0x8a, 0x4e, 0xf0, 0x13, 0x58, 0x91, 0x18, 0x18, 0x18,
	0xd8, 0x58, 0xf8, 0x11, 0x6c, 0x74, 0x64, 0x6c, 0xcd, 0xc2, 0xc8, 0x4f, 0x40, 0xef, 0xd9, 0x71,
	0xd3, 0x90, 0x42, 0x25, 0x54, 0xd8, 0xee, 0xb9, 0xe7, 0xe6, 0xe4, 0x9c, 0xfb, 0x6e, 0x02, 0x55,
	0x12, 0xf9, 0x2f, 0xc2, 0x61, 0x14, 0x87, 0x49, 0xb8, 0xb3, 0xf7, 0xf4, 0x4e, 0x06, 0xeb, 0x0c,
	0x63, 0xed, 0x34, 0x69, 0x7d, 0x41, 0xa0, 0xb6, 0x62, 0xb2, 0x18, 0x04, 0x24, 0x4a, 0x70, 0x15,
	0xd4, 0x3e, 0xf1, 0x3b, 0x24, 0xde, 0xee, 0x76, 0x0c, 0x34, 0x8f, 0x6a, 0x92, 0x57, 0xca, 0x1a,
	0x2b, 0x1d, 0x6c, 0x80, 0x12, 0x93, 0xa8, 0xdf, 0x0d, 0x7c, 0x83, 0x67, 0xd4, 0x08, 0xe2, 0x39,
	0x28, 0x75, 0x07, 0xc3, 0xc4, 0x1f, 0x04, 0xc4, 0x10, 0xb2, 0x4f, 0x8d, 0x30, 0x9e, 0x05, 0x79,
	0xc7, 0xef, 0xf7, 0xc3, 0xc4, 0x10, 0x19, 0x93, 0x23, 0xac, 0x83, 0x30, 0x24, 0xcf, 0x0d, 0x89,
	0x35, 0x69, 0x89, 0x31, 0x88, 0x1d, 0x12, 0x0d, 0x0d, 0x79, 0x5e, 0xa8, 0x49, 0x1e, 0xab, 0xf1,
	0x02, 0x28, 0x41, 0xb8, 0xbb, 0xeb, 0x0f, 0x3a, 0x86, 0x32, 0x2f, 0xd4, 0xca, 0x8d, 0xab, 0xf5,
	0xd3, 0x01, 0xea, 0x76, 0x46, 0x7b, 0xa3, 0x39, 0x9a, 0x48, 0x2b, 0x12, 0x79, 0x24, 0xea, 0x1f,
	0x8c, 0x3b, 0x47, 0x67, 0x3b, 0xe7, 0x27, 0x9c, 0x5b, 0xc0, 0x87, 0x3d, 0x96, 0x47, 0x6b, 0xe0,
	0xc9, 0xaf, 0x75, 0x9b, 0x1e, 0x1f, 0xf6, 0xfe, 0x32, 0xdd, 0x0d, 0xd0, 0xa8, 0xeb, 0x6e, 0x92,
	0x90, 0xce, 0x36, 0x63, 0x15, 0xc6, 0x56, 0x8a, 0xee, 0x32, 0x89, 0x86, 0xd6, 0x4d, 0x28, 0x17,
	0x81, 0xdc, 0x26, 0xf5, 0xbc, 0x32, 0xf2, 0x8c, 0x4e, 0x7b, 0xb6, 0x3e, 0x22, 0x90, 0xff, 0xfd,
	0x5b, 0x5e, 0x06, 0x29, 0x08, 0xf7, 0x06, 0x49, 0x9e, 0x37, 0x03, 0xa3, 0x1d, 0xc8, 0xbf, 0xee,
	0x40, 0x39, 0xd9, 0x81, 0xf5, 0x12, 0xca, 0xff, 0xf5, 0xa9, 0xac, 0x4f, 0x08, 0x64, 0x9b, 0xed,
	0xfb, 0x22, 0x56, 0x36, 0x76, 0xc0, 0xe2, 0xf9, 0x0e, 0xf8, 0x7c, 0xb7, 0x63, 0xbd, 0x45, 0x50,
	0xce, 0x6c, 0x6f, 0x3c, 0x0b, 0xe3, 0x0b, 0xf1, 0x5e, 0x3c, 0xab, 0x38, 0xe5, 0x59, 0xff, 0x60,
	0xef, 0x3d, 0x02, 0x25, 0x4f, 0x86, 0x17, 0x80, 0x0f, 0x23, 0xe6, 0x49, 0x6b, 0x5c, 0x3f, 0x23,
	0x7e, 0xdd, 0x8d, 0x48, 0xec, 0x27, 0xdd, 0x70, 0xe0, 0xf1, 0x61, 0x84, 0x67, 0x00, 0xf5, 0x98,
	0x55, 0xc1, 0x43, 0x3d, 0x8a, 0xf6, 0x99, 0x3b, 0xc1, 0x43, 0xfb, 0xd6, 0x43, 0x50, 0x8b, 0x61,
	0xac, 0x82, 0xb4, 0xee, 0xae, 0x3b, 0x5b, 0x3a, 0x87, 0x15, 0x10, 0x5a, 0x9b, 0x6d, 0x1d, 0xd1,
	0xe2, 0xbe, 0xd3, 0xd6, 0x79, 0x0c, 0x20, 0x2f, 0x3b, 0xab, 0x4e, 0xdb, 0xd1, 0x05, 0x3a, 0xe8,
	0xad, 0xba, 0x76, 0x53, 0x17, 0x69, 0xf9, 0x98, 0x95, 0x92, 0xa5, 0x80, 0xe4, 0xec, 0x46, 0xc9,
	0xc1, 0xad, 0x27, 0xc0, 0xbb, 0x4d, 0x5c, 0x02, 0x91, 0xaa, 0xe9, 0x1c, 0xbe, 0x04, 0xe5, 0x96,
	0xe7, 0x2c, 0xda, 0xb6, 0xd3, 0x6a, 0x3b, 0xcb, 0x3a, 0xc2, 0x18, 0xb4, 0xb1, 0xc6, 0xb6, 0xf3,
	0x48, 0xe7, 0xf1, 0x0c, 0x94, 0x8a, 0x09, 0x01, 0x57, 0x40, 0xb5, 0xdd, 0xb5, 0xb5, 0x95, 0x36,
	0x85, 0x22, 0x25, 0x9d, 0x2d, 0xc7, 0xde, 0xa4, 0x48, 0x6a, 0xbc, 0x43, 0x50, 0xc9, 0xee, 0x7c,
	0x83, 0xc4, 0xfb, 0xdd, 0x80, 0xe0, 0x26, 0xcc, 0x9c, 0xfc, 0x4d, 0xb5, 0x6c, 0x7c, 0x6d, 0x72,
	0x33, 0x05, 0x3b, 0x67, 0x9e, 0x49, 0xb1, 0x1f, 0x8d, 0xc5, 0xe1, 0x25, 0x50, 0x4f, 0x94, 0x66,
	0x27, 0xc7, 0x73, 0x99, 0xea, 0xf4, 0x7e, 0xae, 0xd1, 0x78, 0x83, 0xa0, 0x92, 0x5f, 0x54, 0x6e,
	0xf1, 0x1e, 0xa8, 0x59, 0x63, 0xaa, 0x6a, 0x46, 0xcd, 0x5d, 0x99, 0xec, 0xb3, 0x85, 0x5a, 0x5c,
	0x0d, 0xe1, 0x07, 0xa0, 0x8d, 0x9d, 0x28, 0x15, 0xa9, 0x4e, 0x17, 0x61, 0xfc, 0x6f, 0x94, 0x96,
	0x6e, 0x1f, 0x1e, 0x9b, 0xdc, 0xd7, 0x63, 0x93, 0x3b, 0x3a, 0x36, 0xd1, 0xab, 0xd4, 0x44, 0x1f,
	0x52, 0x13, 0x7d, 0x4e, 0x4d, 0x74, 0x98, 0x9a, 0xe8, 0x28, 0x35, 0xd1, 0xf7, 0xd4, 0xe4, 0x7e,
	0xa4, 0x26, 0x7a, 0xfd, 0xcd, 0xe4, 0x76, 0x64, 0xa6, 0x70, 0xf7, 0x67, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x68, 0xfd, 0x90, 0xc3, 0x0a, 0x07, 0x00, 0x00,
}
