// Code generated by protoc-gen-gogo.
// source: epaxosprotobuf/epaxos.proto
// DO NOT EDIT!

/*
	Package epaxosprotobuf is a generated protocol buffer package.

	It is generated from these files:
		epaxosprotobuf/epaxos.proto

	It has these top-level messages:
		PreAccept
		PreAcceptReply
		PreAcceptOK
		Accept
		AcceptReply
		Commit
		CommitShort
		Command
*/
package epaxosprotobuf

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"
import github_com_relab_epaxos_fastrpc "github.com/relab/epaxos/fastrpc"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type OK int32

const (
	NONE           OK = 0
	PREACCEPTED    OK = 1
	PREACCEPTED_EQ OK = 2
	ACCEPTED       OK = 3
	COMMITTED      OK = 4
	EXECUTED       OK = 5
)

var OK_name = map[int32]string{
	0: "NONE",
	1: "PREACCEPTED",
	2: "PREACCEPTED_EQ",
	3: "ACCEPTED",
	4: "COMMITTED",
	5: "EXECUTED",
}
var OK_value = map[string]int32{
	"NONE":           0,
	"PREACCEPTED":    1,
	"PREACCEPTED_EQ": 2,
	"ACCEPTED":       3,
	"COMMITTED":      4,
	"EXECUTED":       5,
}

func (x OK) String() string {
	return proto.EnumName(OK_name, int32(x))
}
func (OK) EnumDescriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{0} }

type Command_Operation int32

const (
	NONEX  Command_Operation = 0
	PUT    Command_Operation = 1
	GET    Command_Operation = 2
	DELETE Command_Operation = 3
	RLOCK  Command_Operation = 4
	WLOCK  Command_Operation = 5
)

var Command_Operation_name = map[int32]string{
	0: "NONEX",
	1: "PUT",
	2: "GET",
	3: "DELETE",
	4: "RLOCK",
	5: "WLOCK",
}
var Command_Operation_value = map[string]int32{
	"NONEX":  0,
	"PUT":    1,
	"GET":    2,
	"DELETE": 3,
	"RLOCK":  4,
	"WLOCK":  5,
}

func (x Command_Operation) String() string {
	return proto.EnumName(Command_Operation_name, int32(x))
}
func (Command_Operation) EnumDescriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{7, 0} }

type PreAccept struct {
	LeaderId int32      `protobuf:"varint,1,opt,name=leader_id,json=leaderId,proto3" json:"leader_id,omitempty"`
	Replica  int32      `protobuf:"varint,2,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance int32      `protobuf:"varint,3,opt,name=instance,proto3" json:"instance,omitempty"`
	Ballot   int32      `protobuf:"varint,4,opt,name=ballot,proto3" json:"ballot,omitempty"`
	Seq      int32      `protobuf:"varint,5,opt,name=seq,proto3" json:"seq,omitempty"`
	Deps     []int32    `protobuf:"varint,6,rep,name=deps" json:"deps,omitempty"`
	Command  []*Command `protobuf:"bytes,7,rep,name=command" json:"command,omitempty"`
}

func (m *PreAccept) Reset()                    { *m = PreAccept{} }
func (m *PreAccept) String() string            { return proto.CompactTextString(m) }
func (*PreAccept) ProtoMessage()               {}
func (*PreAccept) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{0} }

func (m *PreAccept) GetCommand() []*Command {
	if m != nil {
		return m.Command
	}
	return nil
}

type PreAcceptReply struct {
	Replica       int32   `protobuf:"varint,1,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance      int32   `protobuf:"varint,2,opt,name=instance,proto3" json:"instance,omitempty"`
	Ok            OK      `protobuf:"varint,3,opt,name=ok,proto3,enum=epaxosprotobuf.OK" json:"ok,omitempty"`
	Ballot        int32   `protobuf:"varint,4,opt,name=ballot,proto3" json:"ballot,omitempty"`
	Seq           int32   `protobuf:"varint,5,opt,name=seq,proto3" json:"seq,omitempty"`
	Deps          []int32 `protobuf:"varint,6,rep,name=deps" json:"deps,omitempty"`
	CommittedDeps []int32 `protobuf:"varint,7,rep,name=committed_deps,json=committedDeps" json:"committed_deps,omitempty"`
}

func (m *PreAcceptReply) Reset()                    { *m = PreAcceptReply{} }
func (m *PreAcceptReply) String() string            { return proto.CompactTextString(m) }
func (*PreAcceptReply) ProtoMessage()               {}
func (*PreAcceptReply) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{1} }

type PreAcceptOK struct {
	Instance int32 `protobuf:"varint,1,opt,name=Instance,json=instance,proto3" json:"Instance,omitempty"`
}

func (m *PreAcceptOK) Reset()                    { *m = PreAcceptOK{} }
func (m *PreAcceptOK) String() string            { return proto.CompactTextString(m) }
func (*PreAcceptOK) ProtoMessage()               {}
func (*PreAcceptOK) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{2} }

type Accept struct {
	LeaderId int32   `protobuf:"varint,1,opt,name=leader_id,json=leaderId,proto3" json:"leader_id,omitempty"`
	Replica  int32   `protobuf:"varint,2,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance int32   `protobuf:"varint,3,opt,name=instance,proto3" json:"instance,omitempty"`
	Ballot   int32   `protobuf:"varint,4,opt,name=ballot,proto3" json:"ballot,omitempty"`
	Count    int32   `protobuf:"varint,5,opt,name=count,proto3" json:"count,omitempty"`
	Seq      int32   `protobuf:"varint,6,opt,name=seq,proto3" json:"seq,omitempty"`
	Deps     []int32 `protobuf:"varint,7,rep,name=deps" json:"deps,omitempty"`
}

func (m *Accept) Reset()                    { *m = Accept{} }
func (m *Accept) String() string            { return proto.CompactTextString(m) }
func (*Accept) ProtoMessage()               {}
func (*Accept) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{3} }

type AcceptReply struct {
	Replica  int32 `protobuf:"varint,1,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance int32 `protobuf:"varint,2,opt,name=instance,proto3" json:"instance,omitempty"`
	Ok       OK    `protobuf:"varint,3,opt,name=ok,proto3,enum=epaxosprotobuf.OK" json:"ok,omitempty"`
	Ballot   int32 `protobuf:"varint,4,opt,name=ballot,proto3" json:"ballot,omitempty"`
}

func (m *AcceptReply) Reset()                    { *m = AcceptReply{} }
func (m *AcceptReply) String() string            { return proto.CompactTextString(m) }
func (*AcceptReply) ProtoMessage()               {}
func (*AcceptReply) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{4} }

type Commit struct {
	LeaderId int32      `protobuf:"varint,1,opt,name=leader_id,json=leaderId,proto3" json:"leader_id,omitempty"`
	Replica  int32      `protobuf:"varint,2,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance int32      `protobuf:"varint,3,opt,name=instance,proto3" json:"instance,omitempty"`
	Command  []*Command `protobuf:"bytes,4,rep,name=command" json:"command,omitempty"`
	Seq      int32      `protobuf:"varint,5,opt,name=seq,proto3" json:"seq,omitempty"`
	Deps     []int32    `protobuf:"varint,6,rep,name=deps" json:"deps,omitempty"`
}

func (m *Commit) Reset()                    { *m = Commit{} }
func (m *Commit) String() string            { return proto.CompactTextString(m) }
func (*Commit) ProtoMessage()               {}
func (*Commit) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{5} }

func (m *Commit) GetCommand() []*Command {
	if m != nil {
		return m.Command
	}
	return nil
}

type CommitShort struct {
	LeaderId int32   `protobuf:"varint,1,opt,name=leader_id,json=leaderId,proto3" json:"leader_id,omitempty"`
	Replica  int32   `protobuf:"varint,2,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance int32   `protobuf:"varint,3,opt,name=instance,proto3" json:"instance,omitempty"`
	Count    int32   `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	Seq      int32   `protobuf:"varint,5,opt,name=seq,proto3" json:"seq,omitempty"`
	Deps     []int32 `protobuf:"varint,6,rep,name=deps" json:"deps,omitempty"`
}

func (m *CommitShort) Reset()                    { *m = CommitShort{} }
func (m *CommitShort) String() string            { return proto.CompactTextString(m) }
func (*CommitShort) ProtoMessage()               {}
func (*CommitShort) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{6} }

type Command struct {
	Op Command_Operation `protobuf:"varint,1,opt,name=op,proto3,enum=epaxosprotobuf.Command_Operation" json:"op,omitempty"`
	K  int64             `protobuf:"varint,2,opt,name=k,proto3" json:"k,omitempty"`
	V  int64             `protobuf:"varint,3,opt,name=v,proto3" json:"v,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (m *Command) String() string            { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{7} }

func init() {
	proto.RegisterType((*PreAccept)(nil), "epaxosprotobuf.PreAccept")
	proto.RegisterType((*PreAcceptReply)(nil), "epaxosprotobuf.PreAcceptReply")
	proto.RegisterType((*PreAcceptOK)(nil), "epaxosprotobuf.PreAcceptOK")
	proto.RegisterType((*Accept)(nil), "epaxosprotobuf.Accept")
	proto.RegisterType((*AcceptReply)(nil), "epaxosprotobuf.AcceptReply")
	proto.RegisterType((*Commit)(nil), "epaxosprotobuf.Commit")
	proto.RegisterType((*CommitShort)(nil), "epaxosprotobuf.CommitShort")
	proto.RegisterType((*Command)(nil), "epaxosprotobuf.Command")
	proto.RegisterEnum("epaxosprotobuf.OK", OK_name, OK_value)
	proto.RegisterEnum("epaxosprotobuf.Command_Operation", Command_Operation_name, Command_Operation_value)
}
func (m *PreAccept) New() github_com_relab_epaxos_fastrpc.Serializable {
	return new(PreAccept)
}

func (m *PreAccept) Marshal(w io.Writer) {
	size := m.Size()
	data := make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		panic(err)
	}
	w.Write(data[:n])
}

func (m *PreAccept) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LeaderId != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.LeaderId))
	}
	if m.Replica != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Instance))
	}
	if m.Ballot != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Ballot))
	}
	if m.Seq != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		for _, num := range m.Deps {
			data[i] = 0x30
			i++
			i = encodeVarintEpaxos(data, i, uint64(num))
		}
	}
	if len(m.Command) > 0 {
		for _, msg := range m.Command {
			data[i] = 0x3a
			i++
			i = encodeVarintEpaxos(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PreAcceptReply) New() github_com_relab_epaxos_fastrpc.Serializable {
	return new(PreAcceptReply)
}

func (m *PreAcceptReply) Marshal(w io.Writer) {
	size := m.Size()
	data := make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		panic(err)
	}
	w.Write(data[:n])
}

func (m *PreAcceptReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Replica != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Instance))
	}
	if m.Ok != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Ok))
	}
	if m.Ballot != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Ballot))
	}
	if m.Seq != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		for _, num := range m.Deps {
			data[i] = 0x30
			i++
			i = encodeVarintEpaxos(data, i, uint64(num))
		}
	}
	if len(m.CommittedDeps) > 0 {
		for _, num := range m.CommittedDeps {
			data[i] = 0x38
			i++
			i = encodeVarintEpaxos(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *PreAcceptOK) New() github_com_relab_epaxos_fastrpc.Serializable {
	return new(PreAcceptOK)
}

func (m *PreAcceptOK) Marshal(w io.Writer) {
	size := m.Size()
	data := make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		panic(err)
	}
	w.Write(data[:n])
}

func (m *PreAcceptOK) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Instance != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Instance))
	}
	return i, nil
}

func (m *Accept) New() github_com_relab_epaxos_fastrpc.Serializable {
	return new(Accept)
}

func (m *Accept) Marshal(w io.Writer) {
	size := m.Size()
	data := make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		panic(err)
	}
	w.Write(data[:n])
}

func (m *Accept) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LeaderId != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.LeaderId))
	}
	if m.Replica != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Instance))
	}
	if m.Ballot != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Ballot))
	}
	if m.Count != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Count))
	}
	if m.Seq != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		for _, num := range m.Deps {
			data[i] = 0x38
			i++
			i = encodeVarintEpaxos(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *AcceptReply) New() github_com_relab_epaxos_fastrpc.Serializable {
	return new(AcceptReply)
}

func (m *AcceptReply) Marshal(w io.Writer) {
	size := m.Size()
	data := make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		panic(err)
	}
	w.Write(data[:n])
}

func (m *AcceptReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Replica != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Instance))
	}
	if m.Ok != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Ok))
	}
	if m.Ballot != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Ballot))
	}
	return i, nil
}

func (m *Commit) New() github_com_relab_epaxos_fastrpc.Serializable {
	return new(Commit)
}

func (m *Commit) Marshal(w io.Writer) {
	size := m.Size()
	data := make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		panic(err)
	}
	w.Write(data[:n])
}

func (m *Commit) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LeaderId != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.LeaderId))
	}
	if m.Replica != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Instance))
	}
	if len(m.Command) > 0 {
		for _, msg := range m.Command {
			data[i] = 0x22
			i++
			i = encodeVarintEpaxos(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Seq != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		for _, num := range m.Deps {
			data[i] = 0x30
			i++
			i = encodeVarintEpaxos(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *CommitShort) New() github_com_relab_epaxos_fastrpc.Serializable {
	return new(CommitShort)
}

func (m *CommitShort) Marshal(w io.Writer) {
	size := m.Size()
	data := make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		panic(err)
	}
	w.Write(data[:n])
}

func (m *CommitShort) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LeaderId != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.LeaderId))
	}
	if m.Replica != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Instance))
	}
	if m.Count != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Count))
	}
	if m.Seq != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		for _, num := range m.Deps {
			data[i] = 0x30
			i++
			i = encodeVarintEpaxos(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *Command) New() *Command {
	return new(Command)
}

func (m *Command) Marshal(w io.Writer) {
	size := m.Size()
	data := make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		panic(err)
	}
	w.Write(data[:n])
}

func (m *Command) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.Op))
	}
	if m.K != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.K))
	}
	if m.V != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintEpaxos(data, i, uint64(m.V))
	}
	return i, nil
}

func encodeFixed64Epaxos(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Epaxos(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintEpaxos(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *PreAccept) Size() (n int) {
	var l int
	_ = l
	if m.LeaderId != 0 {
		n += 1 + sovEpaxos(uint64(m.LeaderId))
	}
	if m.Replica != 0 {
		n += 1 + sovEpaxos(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovEpaxos(uint64(m.Instance))
	}
	if m.Ballot != 0 {
		n += 1 + sovEpaxos(uint64(m.Ballot))
	}
	if m.Seq != 0 {
		n += 1 + sovEpaxos(uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		for _, e := range m.Deps {
			n += 1 + sovEpaxos(uint64(e))
		}
	}
	if len(m.Command) > 0 {
		for _, e := range m.Command {
			l = e.Size()
			n += 1 + l + sovEpaxos(uint64(l))
		}
	}
	return n
}

func (m *PreAcceptReply) Size() (n int) {
	var l int
	_ = l
	if m.Replica != 0 {
		n += 1 + sovEpaxos(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovEpaxos(uint64(m.Instance))
	}
	if m.Ok != 0 {
		n += 1 + sovEpaxos(uint64(m.Ok))
	}
	if m.Ballot != 0 {
		n += 1 + sovEpaxos(uint64(m.Ballot))
	}
	if m.Seq != 0 {
		n += 1 + sovEpaxos(uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		for _, e := range m.Deps {
			n += 1 + sovEpaxos(uint64(e))
		}
	}
	if len(m.CommittedDeps) > 0 {
		for _, e := range m.CommittedDeps {
			n += 1 + sovEpaxos(uint64(e))
		}
	}
	return n
}

func (m *PreAcceptOK) Size() (n int) {
	var l int
	_ = l
	if m.Instance != 0 {
		n += 1 + sovEpaxos(uint64(m.Instance))
	}
	return n
}

func (m *Accept) Size() (n int) {
	var l int
	_ = l
	if m.LeaderId != 0 {
		n += 1 + sovEpaxos(uint64(m.LeaderId))
	}
	if m.Replica != 0 {
		n += 1 + sovEpaxos(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovEpaxos(uint64(m.Instance))
	}
	if m.Ballot != 0 {
		n += 1 + sovEpaxos(uint64(m.Ballot))
	}
	if m.Count != 0 {
		n += 1 + sovEpaxos(uint64(m.Count))
	}
	if m.Seq != 0 {
		n += 1 + sovEpaxos(uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		for _, e := range m.Deps {
			n += 1 + sovEpaxos(uint64(e))
		}
	}
	return n
}

func (m *AcceptReply) Size() (n int) {
	var l int
	_ = l
	if m.Replica != 0 {
		n += 1 + sovEpaxos(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovEpaxos(uint64(m.Instance))
	}
	if m.Ok != 0 {
		n += 1 + sovEpaxos(uint64(m.Ok))
	}
	if m.Ballot != 0 {
		n += 1 + sovEpaxos(uint64(m.Ballot))
	}
	return n
}

func (m *Commit) Size() (n int) {
	var l int
	_ = l
	if m.LeaderId != 0 {
		n += 1 + sovEpaxos(uint64(m.LeaderId))
	}
	if m.Replica != 0 {
		n += 1 + sovEpaxos(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovEpaxos(uint64(m.Instance))
	}
	if len(m.Command) > 0 {
		for _, e := range m.Command {
			l = e.Size()
			n += 1 + l + sovEpaxos(uint64(l))
		}
	}
	if m.Seq != 0 {
		n += 1 + sovEpaxos(uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		for _, e := range m.Deps {
			n += 1 + sovEpaxos(uint64(e))
		}
	}
	return n
}

func (m *CommitShort) Size() (n int) {
	var l int
	_ = l
	if m.LeaderId != 0 {
		n += 1 + sovEpaxos(uint64(m.LeaderId))
	}
	if m.Replica != 0 {
		n += 1 + sovEpaxos(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovEpaxos(uint64(m.Instance))
	}
	if m.Count != 0 {
		n += 1 + sovEpaxos(uint64(m.Count))
	}
	if m.Seq != 0 {
		n += 1 + sovEpaxos(uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		for _, e := range m.Deps {
			n += 1 + sovEpaxos(uint64(e))
		}
	}
	return n
}

func (m *Command) Size() (n int) {
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovEpaxos(uint64(m.Op))
	}
	if m.K != 0 {
		n += 1 + sovEpaxos(uint64(m.K))
	}
	if m.V != 0 {
		n += 1 + sovEpaxos(uint64(m.V))
	}
	return n
}

func sovEpaxos(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozEpaxos(x uint64) (n int) {
	return sovEpaxos(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PreAccept) Unmarshal(r io.Reader, size int) error {
	data := make([]byte, size)
	_, err := io.ReadFull(r, data)
	if err != nil {
		panic("unmarshal read full err")
	}
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreAccept: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreAccept: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderId", wireType)
			}
			m.LeaderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LeaderId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ballot", wireType)
			}
			m.Ballot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ballot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deps", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deps = append(m.Deps, v)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, &Command{})
			if err := m.Command[len(m.Command)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreAcceptReply) Unmarshal(r io.Reader, size int) error {
	data := make([]byte, size)
	_, err := io.ReadFull(r, data)
	if err != nil {
		panic("unmarshal read full err")
	}
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreAcceptReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreAcceptReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			m.Ok = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ok |= (OK(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ballot", wireType)
			}
			m.Ballot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ballot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deps", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deps = append(m.Deps, v)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedDeps", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CommittedDeps = append(m.CommittedDeps, v)
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreAcceptOK) Unmarshal(r io.Reader, size int) error {
	data := make([]byte, size)
	_, err := io.ReadFull(r, data)
	if err != nil {
		panic("unmarshal read full err")
	}
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreAcceptOK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreAcceptOK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Accept) Unmarshal(r io.Reader, size int) error {
	data := make([]byte, size)
	_, err := io.ReadFull(r, data)
	if err != nil {
		panic("unmarshal read full err")
	}
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Accept: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Accept: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderId", wireType)
			}
			m.LeaderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LeaderId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ballot", wireType)
			}
			m.Ballot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ballot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deps", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deps = append(m.Deps, v)
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptReply) Unmarshal(r io.Reader, size int) error {
	data := make([]byte, size)
	_, err := io.ReadFull(r, data)
	if err != nil {
		panic("unmarshal read full err")
	}
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			m.Ok = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ok |= (OK(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ballot", wireType)
			}
			m.Ballot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ballot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Commit) Unmarshal(r io.Reader, size int) error {
	data := make([]byte, size)
	_, err := io.ReadFull(r, data)
	if err != nil {
		panic("unmarshal read full err")
	}
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Commit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Commit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderId", wireType)
			}
			m.LeaderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LeaderId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, &Command{})
			if err := m.Command[len(m.Command)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deps", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deps = append(m.Deps, v)
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitShort) Unmarshal(r io.Reader, size int) error {
	data := make([]byte, size)
	_, err := io.ReadFull(r, data)
	if err != nil {
		panic("unmarshal read full err")
	}
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitShort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitShort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderId", wireType)
			}
			m.LeaderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LeaderId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deps", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deps = append(m.Deps, v)
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Command) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Op |= (Command_Operation(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			m.K = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.K |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			m.V = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.V |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEpaxos(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthEpaxos
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowEpaxos
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipEpaxos(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthEpaxos = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEpaxos   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("epaxosprotobuf/epaxos.proto", fileDescriptorEpaxos) }

var fileDescriptorEpaxos = []byte{
	// 533 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xc4, 0x92, 0xcf, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0xb3, 0xfe, 0x9b, 0x4c, 0x5a, 0x63, 0x8d, 0x10, 0x58, 0x54, 0x8a, 0x82, 0x25, 0xa4,
	0xc0, 0x21, 0xa8, 0xe1, 0x09, 0x8a, 0xb3, 0x42, 0x21, 0x6d, 0x1d, 0x4c, 0x2a, 0x7a, 0x22, 0x72,
	0xec, 0x45, 0x44, 0x49, 0xb3, 0xc6, 0x71, 0x2b, 0x38, 0xf1, 0x22, 0x1c, 0xb9, 0x73, 0xe1, 0x21,
	0xb8, 0xd1, 0x47, 0x80, 0x3c, 0x09, 0xda, 0x75, 0x6c, 0x92, 0x42, 0x45, 0x25, 0x54, 0xb8, 0xcd,
	0x37, 0xdf, 0x24, 0xfe, 0x7d, 0x33, 0x0b, 0x3b, 0x2c, 0x09, 0xdf, 0xf2, 0x45, 0x92, 0xf2, 0x8c,
	0x8f, 0x4f, 0x5f, 0x3d, 0xcc, 0x65, 0x5b, 0x6a, 0xb4, 0x36, 0x4d, 0xf7, 0x2b, 0x81, 0xda, 0x20,
	0x65, 0x7b, 0x51, 0xc4, 0x92, 0x0c, 0x77, 0xa0, 0x36, 0x63, 0x61, 0xcc, 0xd2, 0xd1, 0x24, 0x76,
	0x48, 0x93, 0xb4, 0xf4, 0xa0, 0x9a, 0x37, 0x7a, 0x31, 0x3a, 0x60, 0xa6, 0x2c, 0x99, 0x4d, 0xa2,
	0xd0, 0x51, 0xa4, 0x55, 0x48, 0xbc, 0x03, 0xd5, 0xc9, 0x7c, 0x91, 0x85, 0xf3, 0x88, 0x39, 0x6a,
	0xfe, 0xab, 0x42, 0xe3, 0x2d, 0x30, 0xc6, 0xe1, 0x6c, 0xc6, 0x33, 0x47, 0x93, 0xce, 0x4a, 0xa1,
	0x0d, 0xea, 0x82, 0xbd, 0x71, 0x74, 0xd9, 0x14, 0x25, 0x22, 0x68, 0x31, 0x4b, 0x16, 0x8e, 0xd1,
	0x54, 0x5b, 0x7a, 0x20, 0x6b, 0xdc, 0x05, 0x33, 0xe2, 0x27, 0x27, 0xe1, 0x3c, 0x76, 0xcc, 0xa6,
	0xda, 0xaa, 0x77, 0x6e, 0xb7, 0x37, 0x03, 0xb4, 0xbd, 0xdc, 0x0e, 0x8a, 0x39, 0x91, 0xc8, 0x2a,
	0x13, 0x05, 0x2c, 0x99, 0xbd, 0x5b, 0x27, 0x27, 0x97, 0x93, 0x2b, 0x17, 0xc8, 0x5d, 0x50, 0xf8,
	0x54, 0xe6, 0xb1, 0x3a, 0x78, 0xf1, 0xb3, 0x7e, 0x3f, 0x50, 0xf8, 0xf4, 0x2f, 0xd3, 0xdd, 0x03,
	0x4b, 0x50, 0x4f, 0xb2, 0x8c, 0xc5, 0x23, 0xe9, 0x9a, 0xd2, 0xdd, 0x2e, 0xbb, 0x5d, 0x96, 0x2c,
	0xdc, 0xfb, 0x50, 0x2f, 0x03, 0xf9, 0x7d, 0xc1, 0xdc, 0x2b, 0x98, 0xc9, 0x26, 0xb3, 0xfb, 0x89,
	0x80, 0xf1, 0xef, 0x6f, 0x79, 0x13, 0xf4, 0x88, 0x9f, 0xce, 0xb3, 0x55, 0xde, 0x5c, 0x14, 0x3b,
	0x30, 0x7e, 0xdd, 0x81, 0xf9, 0x73, 0x07, 0xee, 0x7b, 0xa8, 0xff, 0xd7, 0x53, 0xb9, 0x9f, 0x09,
	0x18, 0x9e, 0xdc, 0xf7, 0x75, 0xac, 0x6c, 0xed, 0x01, 0x6b, 0x57, 0x7b, 0xc0, 0x57, 0x7b, 0x3b,
	0xee, 0x07, 0x02, 0xf5, 0x1c, 0xfb, 0xf9, 0x6b, 0x9e, 0x5e, 0x0b, 0x7b, 0x79, 0x56, 0xed, 0x37,
	0x67, 0xfd, 0x03, 0xde, 0x47, 0x02, 0xe6, 0x2a, 0x19, 0xee, 0x82, 0xc2, 0x13, 0xc9, 0x64, 0x75,
	0xee, 0x5e, 0x12, 0xbf, 0xed, 0x27, 0x2c, 0x0d, 0xb3, 0x09, 0x9f, 0x07, 0x0a, 0x4f, 0x70, 0x0b,
	0xc8, 0x54, 0xa2, 0xaa, 0x01, 0x99, 0x0a, 0x75, 0x26, 0xe9, 0xd4, 0x80, 0x9c, 0xb9, 0x4f, 0xa1,
	0x56, 0x0e, 0x63, 0x0d, 0xf4, 0x43, 0xff, 0x90, 0x1e, 0xdb, 0x15, 0x34, 0x41, 0x1d, 0x1c, 0x0d,
	0x6d, 0x22, 0x8a, 0x27, 0x74, 0x68, 0x2b, 0x08, 0x60, 0x74, 0xe9, 0x3e, 0x1d, 0x52, 0x5b, 0x15,
	0x83, 0xc1, 0xbe, 0xef, 0xf5, 0x6d, 0x4d, 0x94, 0x2f, 0x64, 0xa9, 0x3f, 0x78, 0x09, 0x8a, 0xdf,
	0xc7, 0x2a, 0x68, 0xe2, 0x4f, 0xec, 0x0a, 0xde, 0x80, 0xfa, 0x20, 0xa0, 0x7b, 0x9e, 0x47, 0x07,
	0x43, 0xda, 0xb5, 0x09, 0x22, 0x58, 0x6b, 0x8d, 0x11, 0x7d, 0x66, 0x2b, 0xb8, 0x05, 0xd5, 0x72,
	0x42, 0xc5, 0x6d, 0xa8, 0x79, 0xfe, 0xc1, 0x41, 0x6f, 0x28, 0xa4, 0x26, 0x4c, 0x7a, 0x4c, 0xbd,
	0x23, 0xa1, 0xf4, 0xc7, 0xf6, 0xf9, 0xf7, 0x46, 0xe5, 0xcb, 0xb2, 0x41, 0xce, 0x97, 0x0d, 0xf2,
	0x6d, 0xd9, 0x20, 0x63, 0x43, 0x26, 0x7f, 0xf4, 0x23, 0x00, 0x00, 0xff, 0xff, 0xdb, 0xda, 0xfb,
	0x7a, 0xa6, 0x05, 0x00, 0x00,
}
